<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ string使用]]></title>
    <url>%2F2018%2F04%2F30%2FstringInCpp%2F</url>
    <content type="text"><![CDATA[string 是C++ 标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时 C++ 的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。 声明和初始化 想使用string首先要在头文件中加入&lt;string&gt; 声明方式也很简单 声明 12string a; //声明一个string对象string ss[10]; //声明一个string对象的数组 初始化 使用等号的初始化叫做拷贝初始化，不用等号的初始化叫做直接初始化。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; //默认初始化，一个空字符串 string s1("ssss"); //s1是字面值"ssss"的副本 string s2(s1); //s2是s1的副本 string s3 = s2; //s3是s2的副本 string s4(10, 'c'); //把s4初始化，十个'c' string s5 = "hiya"; //拷贝初始化 string s6 = string(10, 'c');//拷贝初始化，生成一个初始化好的对象，拷贝给s6 //string s(cp, n) char cs[] = "12345"; string s7(cs, 3); //复制字符串cs的前三个字符到s当中 //string s(s2, pos2) string s8 = "asac"; string s9(s8, 2); //从s2的第二个字符开始拷贝，不能超过s2的zise //string s(s2, pos2, len2) string s10 = "qerqfdsdfa"; string s11(s10, 3, 4); //s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义 return 0;&#125; 字符串处理 substr操作 注意substr没有迭代器作为参数的操作 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s = "abcdefg"; //s.substr(pos, n) 返回字符串位置味pos1后面的n个字符组成的串，pos从0开始 string s2 = s.substr(1, 5); //bcdef //s.substr(pos) 得到一个pos到结尾的串 pos从0开始 string s3 = s.substr(4) //efg return 0;&#125; 如果输入的位置超过字符的长度，会抛出一个 out_of_range 的异常 insert操作 注意用迭代器当参数和无符号数当参数的区别 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str = "to be question"; string str2 = "the "; string str3 = "or not to be"; string::iterator it; //s.insert(pos, str) 在s的pos位置插入str str.insert(6, str2); // to be the question //s.insert(pos, str, a, n) 在s的pos位置插入str中插入位置a到后面的n个字符 str.insert(6, str3, 3, 4); // to be not the question //s.insert(pos, cstr, n)//在pos位置插入cstr字符串从开始到后面的n个字符 str.insert(10, "that is cool", 8); // to be not that is the question //s.insert(pos, cstr)在s的pos位置插入cstr str.insert(10, "to be "); // to be not to be that is the question //s.insert(pos, n, ch)在s.pos位置上面插入n个ch str.insert(15, 1, ':'); // to be not to be: that is the question //s.insert(s.it, ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器 it = str.insert(str.begin() + 5, ','); // to be, not to be: that is the question //s.insert(s.it, n, ch)//在s的it所指向位置的前面插入n个ch str.insert (str.end(), 3, '.'); // to be, not to be: that is the question... //s.insert(it, str.ita, str.itb)在it所指向的位置的前面插入[ita,itb)的字符串 str.insert (it+2, str3.begin(), str3.begin()+3); // to be, or not to be: that is the question... return 0;&#125; erase操作 用来执行删除操作 删除操作共有三种 指定pos和len，其中pos为起始位置，pos以及后面len - 1个字符都删除 迭代器，删除迭代器指向的字符 迭代器范围，删除这一范围内的字符串，范围左闭右开 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main ()&#123; string str ("This is an example sentence."); cout &lt;&lt; str &lt;&lt; endl; // "This is an example sentence." // ^^^^^^^^ str.erase (10, 8); //直接指定删除的字符串位置第十个后面的8个字符 cout &lt;&lt; str &lt;&lt; endl; // "This is an sentence." // ^ str.erase (str.begin() + 9); //删除迭代器指向的字符 cout &lt;&lt; str &lt;&lt; endl; // "This is a sentence." // ^^^^^ str.erase (str.begin() + 5, str.end() - 9); //删除迭代器范围的字符 cout &lt;&lt; str &lt;&lt; endl; // "This sentence." return 0;&#125; append和replace操作 append函数可以用来在字符串末尾追加字符和字符串。由于string重载了运算符，也可以用 += 操作实现 replace顾名思义，就是替换的意思，先删除，后增加。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main ()&#123; string str; string str2 = "Writing "; string str3 = "print 10 and then 5 more"; //直接追加一个str2的字符串 str.append(str2); // "Writing " //后面追加str3第6个字符开始的3个字符串 str.append(str3, 6, 3); // "10 " //追加字符串形参的前5个字符 str.append("dots are cool", 5); // "dots " //直接添加 str.append("here: "); // "here: " //添加10个'.' str.append(10, '.'); // ".........." //添加str3迭代器范围的字符串 str.append(str3.begin() + 8, str3.end()); // " and then 5 more" //最后这个比较特殊，意思是添加5个'A'，实际上参数里面的65对应的asc码就是65 str.append&lt;int&gt;(5, 65); // "....." //字符串追加也可以用重载运算符实现 str += "lalala"; cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; replace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main ()&#123; string base = "this is a test string."; string str2 = "n example"; string str3 = "sample phrase"; string str4 = "useful."; // replace signatures used in the same order as described above: // Using positions: 0123456789*123456789*12345 string str = base; // "this is a test string." //第9个字符以及后面的4个字符被str2代替 str.replace(9, 5, str2); // "this is an example string." (1) //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替 str.replace(19, 6, str3, 7, 6); // "this is an example phrase." (2) //第8个字符以及后面的9个字符用字符串参数代替 str.replace(8, 10, "just a"); // "this is just a phrase." (3) //第8个字符以及后面的5个字符用字符串参数的前7个字符替换 str.replace(8, 6, "a shorty", 7); // "this is a short phrase." (4) //第22以及后面的0个字符用3个叹号替换 str.replace(22, 1, 3, '!'); // "this is a short phrase!!!" (5) //迭代器的原理同上 // Using iterators: 0123456789*123456789* str.replace(str.begin(), str.end()-3, str3); // "sample phrase!!!" (1) str.replace(str.begin(), str.begin() + 6,"replace"); // "replace phrase!!!" (3) str.replace(str.begin() + 8, str.begin() + 14, "is coolness", 7); // "replace is cool!!!" (4) str.replace(str.begin() + 12, str.end() - 4, 4, 'o'); // "replace is cooool!!!" (5) str.replace(str.begin() + 11, str.end(), str4.begin(), str4.end()); // "replace is useful." (6) cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; assign操作 assign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main ()&#123; string str; string base = "The quick brown fox jumps over a lazy dog."; // used in the same order as described above: //直接把base赋值给str str.assign(base); std::cout &lt;&lt; str &lt;&lt; endl; //把base第10个字符以及后面的8个字符赋给str str.assign(base, 10, 9); cout &lt;&lt; str &lt;&lt; endl; // "brown fox" //把参数中的0到6个字符串赋给str str.assign("pangrams are cool", 7); cout &lt;&lt; str &lt;&lt; endl; // "pangram" //直接使用参数赋值 str.assign("c-string"); cout &lt;&lt; str &lt;&lt; endl; // "c-string" //给str赋值10个'*'字符 str.assign(10, '*'); cout &lt;&lt; str &lt;&lt; endl; // "**********" //赋值是10个'-' str.assign&lt;int&gt;(10, 0x2D); cout &lt;&lt; str &lt;&lt; endl; // "----------" //指定base迭代器范围的字符串 str.assign(base.begin() + 16, base.end() - 12); cout &lt;&lt; str &lt;&lt; endl; // "fox jumps over" return 0;&#125; string的搜索操作 string类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。 find和rfind函数 find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str ("There are two needles in this haystack with needles."); string str2 ("needle"); // different member versions of find in the same order as above: //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾 size_t found = str.find(str2); //注意size_t if (found! = string::npos) //string::npos指string的结束位置 cout &lt;&lt; "first 'needle' found at: " &lt;&lt; found &lt;&lt; endl; //在str当中，从第found+1的位置开始查找参数字符串的前6个字符 found = str.find("needles are small", found + 1, 6); if (found != string::npos) cout &lt;&lt; "second 'needle' found at: " &lt;&lt; found &lt;&lt; endl; //在str当中查找参数中的字符串 found = str.find("haystack"); if (found != string::npos) cout &lt;&lt; "'haystack' also found at: " &lt;&lt; found &lt;&lt; endl; //查找一个字符 found = str.find('.'); if (found != string::npos) cout &lt;&lt; "Period found at: " &lt;&lt; found &lt;&lt; endl; //组合使用，把str2用参数表中的字符串代替 // let's replace the first needle: str.replace(str.find(str2), str2.length(), "preposition"); cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; rfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str ("The sixth sick sheik's sixth sheep's sick."); string key ("sixth");// ^ //rfind是找最后一个出现的匹配字符串 size_t found = str.rfind(key); if(found != string::npos) &#123; cout&lt;&lt; found &lt;&lt; endl;//输出23 str.replace(found, key.length(), "seventh");//找到的sixth替换成seventh &#125; cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; find_…_of函数 find_first_of(args) 查找args中任何一个字符第一次出现的位置 find_last_of(args) 最后一个出现的位置 find_fist_not_of(args) 查找第一个不在args中的字符 find_last_not_of 查找最后一个不在args中出现的字符 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str1 ("Please, replace the vowels in this sentence by asterisks."); size_t found1 = str1.find_first_of("aeiou"); //把所有元音找出来用*代替 while (found1 != string::npos) &#123; str1[found1] = '*'; found1 = str1.find_first_of("aeiou",found1 + 1); &#125; cout &lt;&lt; str1 &lt;&lt; endl; //在str2中找到第一个不是消协英文字母和空格的字符 string str2 ("look for non-alphabetic characters..."); size_t found2 = str2.find_first_not_of("abcdefghijklmnopqrstuvwxyz "); if (found2 != string::npos) &#123; cout &lt;&lt; "The first non-alphabetic character is " &lt;&lt; str2[found2]; cout &lt;&lt; " at position " &lt;&lt; found2 &lt;&lt; endl; &#125; return 0;&#125; find_last_of和find_last_not_of与first基本相同。 比较与转换 类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。 compare函数 和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。 在compare当中还支持部分比较，里面有6个参数可以设置。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1 = "123", s2 = "123"; cout &lt;&lt; s1.compare(s2) &lt;&lt; endl; //0 s1 = "123", s2 = "1234"; cout &lt;&lt; s1.compare(s2) &lt;&lt; endl; //-1 s1 = "1234", s2 = "123"; cout &lt;&lt; s1.compare(s2) &lt;&lt; endl; //1 string str1 ("green apple"); string str2 ("red apple"); if (str1.compare(str2) != 0) cout &lt;&lt; str1 &lt;&lt; " is not " &lt;&lt; str2 &lt;&lt; endl; //str1的第6个字符以及后面的4个字符和参数比较 if (str1.compare(6,5,"apple") == 0) cout &lt;&lt; "still, " &lt;&lt; str1 &lt;&lt; " is an apple" &lt;&lt; endl; if (str2.compare(str2.size() - 5, 5, "apple") == 0) cout &lt;&lt; "and " &lt;&lt; str2 &lt;&lt; " is also an apple" &lt;&lt; endl; //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较 if (str1.compare(6, 5, str2, 4, 5) == 0) cout &lt;&lt; "therefore, both are apples" &lt;&lt; endl; return 0;&#125; 由于string重载了运算符，可以直接用&gt;,&lt;，==来进行比较，也很方便。 数值转换 在IO的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。 string和数值转换 to_string(val) 把val转换成string stoi(s, p, b) 把字符串s从p开始转换成b进制的int stol(s, p, b) 把字符串s从p开始转换成b进制的long stoul(s, p, b) 把字符串s从p开始转换成b进制的unsigned long stoll(s, p, b) long long stoull(s, p, b) unsigned long long stof(s, p) float stod(s, p) double stold(s, p) long double 注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！ 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1; s1 = to_string(100); cout &lt;&lt; s1 &lt;&lt; endl; int a = stoi(s1, 0, 10) + 1; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; 转载自C++ string的用法和例子]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker简介及使用]]></title>
    <url>%2F2018%2F03%2F27%2Fdocker-tutorial%2F</url>
    <content type="text"><![CDATA[Docker，这个名词第一次听到是从浩哥那里。大概是去年秋天的时候，浩哥让我在服务器上使用docker撘一个内网穿透frp服务器，用来做树莓派的公网访问。后来由于不再使用树莓派也没有再继续了解下去。最近在V站也经常看到关于Docker的帖子，看起来还是蛮有用的，先挖个坑，毕业之前补完。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客GitHub备份，还有一些常用Git操作]]></title>
    <url>%2F2018%2F03%2F25%2FBackUpHexoAndGit%2F</url>
    <content type="text"><![CDATA[年后换了电脑，博客的文件也从旧电脑转到了新的电脑上面，但是总觉得这种方式很不方便，把文件拷来拷去。 由于博客是发布在GitHubPages上的，就想能不能把博客的生成文件也传到GitHub上。但是这样又出现一个新的问题，一个博客我要用两个仓库来存。突然想起来Git的branch，这岂不是正好用来存储源文件和生成的静态文件？ 首先在仓库新建一个Branch，我这里就直接命名为Hexo了，作为Hexo源文件的备份分支。然后把这个分支设置为默认分支，这样写完博客之后直接把源文件git push到GitHub的仓库中，再也不怕硬盘坏掉或者换电脑了。需要这些源文件的时候git clone下来，然后依次执行 123npm install -g hexo-clinpm install hexonpm install 这样环境就跟之前一模一样了。 branch 最近也在学习使用Git了，这个工具真的很强大，后悔没有早点开始使用，在自己的服务器上也搭建了一个Git仓库，记录一些常用的命令： 一般来说日常使用只需要记住下图六个命令。 GitCommand 下面是常用的Git命令清单： 新建代码仓库 12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [curl] 配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时用户信息git config [--global] user.name "name"git config [--global] user.email "eamil_adress" 增加/删除文件 123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支 123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销 12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 参考链接： 常用Git命令清单]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的指针]]></title>
    <url>%2F2018%2F01%2F30%2FpointInCPP%2F</url>
    <content type="text"><![CDATA[指针是C语言的大杀器 C++中的指针，是语言中相当犀利的工具。但它也是一把双刃剑，用得不好就是毁灭整个工程的大杀器。 数据、指令和内存 在冯诺依曼体系中，程序的数据和指令是存放在同一空间中的。在Linux中，它们存放在进程的虚拟内存空间中。(相关内容可以参考程序员的自我修养：一、二、三)因此，对于进程来说，数据和指令并没有本质的差别；其区别仅在于如何理解和使用虚拟内存空间中的内容。如果读取虚拟内存空间某个位置的值来使用，这块内容就是数据，如果执行虚拟内存空间某个位置的代码，这块内容就是指令。决定如何理解和使用虚拟内存空间中的内容的因素，是类型。具体到C和C++语言来说，对应数据的那部分内存，当中存储的自然就是数据；对应函数的那部分内存，当中存储的就是指令。 因此，对于虚拟内存空间中的内容来说，有两个关键要素： 它在哪里(内存地址是多少) 它具有哪些属性，能做哪些事情(它的类型是什么) 指针是对内存区域的抽象 C++中的指针，是一种特殊的复合类型。指针变量中存放着目标对象的内存地址，而与指针相符合的类型，则说明了相应内存区域中的内容有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本是不可解读的，但是如果有一个描述这块内存区域的指针存在，我们就能找到它(地址的作用)，并且合理地使用它(类型的作用)。因此我们说：指针是对内存区域的抽象。 定义和使用指针 指针的定义 在C++中定义指针变量是很简单的。和定义普通的变量基本是一样的，区别仅在于我们需要在变量名称前使用 解引用符号 *来标记这是一个指针。 12int *ip1, *ip2; //ip1 和 ip2 都是指向 int 类型变量的指针变量double d, *dp; //d 是 double 类型变量， dp 是指向 double 类型变量的指针变量 在上述定义中，我们看到ip1 ip2 dp是三个指针，因为在塔门之前用*标记它们是指针。而d是一个普通的double类型变量。同时我们注意到，ip1 ip2在定义之时就确定了它们是指向int类型的变量。这意味着被ip1 ip2指向的内存， 在使用ip1和ip2进行访问时，将被当做int类型的对象来对待。 同理，dp指向的内存，在使用dp进行访问的时候，将被当做是double类型的对象来对待。 在之前我们提到，内存空间中的内容有两个关键要素：地址和类型。在上述定义过程中，我们通过类型与解引用符号*相结合，已经确定了类型，如果要正确使用指针，我们还应该让指针记录一个地址。 获取对象的地址 上面说到，我们在定义指针之后，记录一个地址。在C++中，我们需要使用 取地址符号&amp; 来获取对象的地址。 12int val = 42;int *p = &amp;val; //&amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里 绝大多数情况下，指针的类型和对象的类型需要严格匹配。例如，你不能使用一个指向int类型的指针变量保存一个double类型的对象的地址。 123456double dval = 0.0;double *pd1 = &amp;dval; // 正确：pd1 保存 double 类型变量 dval 的地址double *pd2 = pd1; // 正确：pd1 是 double 类型的指针，可以赋值初始化同样类型的 pd2int *pi1 = &amp;dval; // 错误：不能用指向 int 类型变量的指针保存 double 类型变量的地址int *pi2 = pd1; // 错误：pd1 是 double 类型的指针，不能将其赋值给 int 类型的指针 访问指针指向的对象 在下例中，指针p记录了变量val的地址。因此，我们可以通过解引用指针p来访问变量val。 1234567int val = 42;int *p = &amp;val; // &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里cout &lt;&lt; *p &lt;&lt; endl; // 通过指针 p 访问变量 val，输出 val 的值：42*p = 360; // 通过指针 p 改变变量 val 的值cout &lt;&lt; *p &lt;&lt; endl; // 通过指针 p 访问变量 val，输出 val 的值：360cout &lt;&lt; val &lt;&lt; endl; // 输出 val 的值：360 空指针和空类型的指针 空指针是不指向任何对象的指针，在实际编程中，通常使用空指针作为指针变量有效性的判断标准。 C 语言和老版本 C++ 的空指针字面值是NULL，它定义在stdlib当中；新版本的 C++ 使用nullptr作为空指针字面值。C++ 还支持用字面值常量0初始化指针变量，被这样初始化的指针变量会是一个空指针。 1234567int *p1 = NULL; // C 风格的空指针初始化int *p2 = nullptr; // C++ 风格的空指针初始化int *p3 = 0; // 使用字面值常量 0 初始化空指针if (nullptr == p1) &#123; // 思考一下为什么不是 p1 == nullptr ; // do something&#125; 空类型的指针，指的是形如void *pv的指针。这是一类特殊的指针；这里的空类型，不是说没有类型，而是说空类型的指针，可以用于存储任意类型对象的地址。 1234567double pi = 3.14;void *pv = &amp;pi; // 使用 void * 存放了一个 double 类型对象的地址double *pd = &amp;pi;pd = pv; // 错误：不能将空类型的指针赋值给其他类型的指针pv = pd; // 正确：空类型的指针可以接受任意类型的指针赋值pd = (double *)pv; // 正确：C 风格的强制类型转换pd = reinterpret_cast&lt;double *&gt;(pv); // 正确：C++ 风格的强制类型转换 让我们回顾一下指针的两个要素：地址和类型。由于空类型的指针可以接受任意类型对象的地址，所以，当编译器拿到一个空类型的指针的时候，它无法知道应该按照何种方式解释和使用指针中记录地址中的内容。因此，空类型指针能够做的事情非常有限：做指针之间的比较、作为函数的输入或输出、赋值给另外一个空类型指针。 理解指针的定义 再探变量声明 在 C 和 C++ 中，变量的声明包括一个基本数据类型（或者类类型），以及一组声明符。定义指针使用的解引用符号*是类型修饰符，它是声明符的一部分。因此，在下列语句中，int是基本数据类型，*p是声明符,*是类型修饰符作为声明符的一部分存在。 1int *p; 在同一个变量定义语句中，基本数据类型只能有一个，但是可以有多个形式相同或不同的声明符。这也就是说，同一个语句可以定义出不同类型的变量。 123// pi 是指向 int 型变量的指针；val 是 int 型变量int *pi = nullptr, val = 1024; 理解稍微复杂的指针定义 因为指针本身也是变量，所以它当然也是存储在虚存空间里的。因此，我们当然也可以定义一个指向这一指针的指针。比如： 123int val = 1024;int *p = &amp;val;int **pp = &amp;p; 我们需要仔细理解一下pp的定义。理解这类稍微复杂的定义语句，一个基本的办法就是：从最靠近变量名字的地方开始，一层一层剖析变量的类型。我们来看 距离pp最近的是一个解引用符*，这预示着pp是一个指针，它指向int *类型的变量； 再来看int *，距离*pp最近的，依然是一个解引用符，这意味着*pp也是一个指针，它指向int类型的变量； 因此pp是一个指向指向int类型变量的指针的指针 const与指针 常量的值在生存期内不允许改变。这一特性经常是有用的：可以定义一个常量，然后在多个地方使用；当认为这个常量的值不合适的时候，修改它的定义，即可在所有使用到它的地方生效（而无需依次手工修改）；此外，还可以防止程序意外修改这个值。定义常量，只需要在基本类型前，加上const关键字即可；它是constant的缩写，意为常量。 当const与指针牵扯到一起，就有些复杂了。至少有以下几种情况： 12345678910111213141516171819202122int val = 0; // int 型变量const int cnst = 1; // int 型常量int *pi = &amp;val; // pi 本身是变量，通过 pi 访问的也是变量 // 正确：将变量地址赋值给变量的指针pi = &amp;cnst; // 错误：不允许将常量的地址赋值给变量的指针const int *pci = &amp;cnst; // pci 本身是变量，通过 pci 访问的是常量 (point to const) // 正确：将常量地址赋值给常量的指针pci = &amp;val; // 正确：允许将变量地址赋值给常量的指针int *const cpi = &amp;val; // cpi 本身是常量，通过 cpi 访问的是变量 // 正确：允许将变量地址赋值给变量的指针int fake = 2; // int 型变量cpi = &amp;fake; // 错误：cpi 本身是常量，不能在定义之外赋值const int *const cpci = &amp;val; // cpci 本身是常量，通过 cpci 访问的也是常量 // 正确：允许将变量地址赋值给常量的指针cpci = &amp;fake; // 错误：cpci 本身是常量，不能在定义之外赋值cpci = &amp;cnst; // 错误：cpci 本身是常量，不能在定义之外赋值，哪怕是常量的地址 在《程序员面试宝典》中关于const修饰指针的情况，作者将其分为以下四种情况 12345int b = 500;const int *a = &amp;b; //情况1int const *a = &amp;b; //情况2int * const a = &amp;b; //情况3const int * const a = &amp;b; //情况4 先看情况1，如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号右侧，const就是修饰指针本身，即指针本身是常量。1和2的情况相同，都是指针所指向的内容为常量，这种情况下不允许对内容进行更改操作。 换句话说，如果 a 是一名仓库管理员的话，他所进入的仓库，里面的货物*a是他没有权限允许动的，仓库里面的东西原来是什么就是什么 123int b =500;const int *a = &amp;b;*a = 600; //错误 但是也有别的办法修改*a的值，一个是通过改变 b 的值 1234int b =500;const int *a = &amp;b;b = 600;cout &lt;&lt; *a &lt;&lt; endl; //得到600 还有一种是让a指向别处(管理员换个仓库) 1234int b =500, c = 600;const int *a = &amp;b;a = &amp;c;cout &lt;&lt; *a &lt;&lt; endl; //得到600 此外，对于这种情况，可以先不初始化。因为虽然指针内容是常量，但指针本身不是常量。 1const int *a; 情况2与情况1相同，情况3位指针本身是敞亮，这种情况下不能对指针本身进行更改操作，而指针所指向的内容不是常量。举例来说，如果 a 是一名仓库管理员的话，他只能进入指定的仓库，而不能去别的仓库，所以a++;是错误的，但是这个仓库里面的货物是可以改动的，*a = 600;是正确的。 情况3定义时必须同时初始化 12345int b = 500, c = 600;int * const a; //错误 没有初始化int * const a = &amp;b; //正确 必须初始化*a = 600; //正确 允许改值cout &lt;&lt; a++ &lt;&lt; endl; //错误 对于情况4指针本身和指向的内容均为常亮，那么这个仓库管理员只能去特定的仓库，并且仓库里面所有的货物他都没有权限去改动。 指针与数组 数组的名字被当做指针使用 在 C 和 C++ 中，指针与数组有非常紧密的联系。实际上，使用数组的时候，编译器通常都是在操作指针。这里我们从两个角度说明数组名在很多时候被当做是一个指针。 12345678int nums[] = &#123;1, 2, 3&#125;;int *p = &amp;(nums[0]);if (p == nums) &#123; printf("true!\n");&#125;for (int i = 0; i &lt; 3; i++) &#123; printf("%d\n", p[i]);&#125; 如果你执行这一小段代码，那么，不出意外的话，程序会在终端上打印true!，以及nums中的三个数字。这预示着，指针变量p保存的内容（也就是nums[0]的地址）和nums保存的内容是完全一样的；同时，编译器以相同的方式去解释p和nums。显然p是一个指向int型变量的指针，那么nums也就是一个指针了。 C++11 标准引入了auto关键字，它能够在定义变量时，探测初始值的类型，并为新定义的变量设置合适的类型。我们看看auto关键字作用于数组名字的时候，会发生什么。 1234int nums[] = &#123;1, 2, 3&#125;;auto what = nums;int val = 42;what = &amp;val; 这份代码在 C++11 标准中，可以顺利通过。这说明what的类型，经由auto检测，是int *。 这两个例子，足以说明：当数组名字被当做是一个值来使用的时候，它就相当于是一个指针。 也不是全部时候 当然，也不是全部时候，数组名字都被当做是简单的指针。比如，前作中的使用方式表明，在数组名字被传入 sizeof()运算符的时候，它会被当做是一个真实的数组来看待。 数组指针可以自增 数组的指针，可以像 C++ 中std::vector的迭代器那样进行自增操作。这句话不是太严谨，因为，实际上是先有数组的指针，再有std::vector的迭代器；迭代器实际上是仿造数组的指针设计的功能。 前文提到，数组的指针，实际上是一个指向数组元素类型的对象的指针。数组的指针进行自增、自减运算，实际是将指针所指的位置，沿着数组向后或者向前移动一个元素。 123456int nums[] = &#123;0,1,2,3,4,5&#125;;size_t len = sizeof(nums) / sizeof(nums[0]);int *iter, end = nums[len]; // end 是尾后指针for (iter = nums; iter != end; ++iter) &#123; printf("%d\n", *iter);&#125; 像这样的用法，就和std::vector的迭代器几乎没有差别了。 数组指针可以进行加减运算 数组的指针还可以进行加减运算。比如，在上述例子中iter += 2，就是将iter指针沿着数组向后移动 2 个元素。 两个指针如果指向同一个数组中的元素，那么它们可以做差。做差得到的结果是两个指针之间的距离，这个结果可以是负数（实际类型是ptrdiff_t）。例如，在上述例子中在循环体末尾处，如果进行end - iter计算，则其结果表示当前尚未打印的元素的数量。 数组下标与指针加减 上面提到，数组指针可以进行加减运算：数组指针与整数的加减，实际是将指针沿着数组进行移动，得到的结果还是一个指针。既然结果是指针，那么就可以解引用，访问数组中的元素。因此有 123456789int nums[] = &#123;0,1,2,3,4&#125;;size_t len = sizeof(nums) / sizeof(nums[0]);int *p = nums;size_t i = 0;for (i = 0; i != len; ++i) &#123; if (nums[i] == *(p + i)) &#123; printf("true!\n"); &#125;&#125; 不出意外的话，这一小段代码会连续打印五行true!。这提供了另一种访问数组内元素的方法；而事实上，在使用下标访问数组元素的时候，编译器都会转换成类似*(nums + i)的形式。也就是说，通过指针运算和解引用来访问数组元素，其实是更加本质的方式。 函数与指针 函数与指针，基本上是指针相关的话题中，最复杂的一个了。 让函数返回一个数组的指针 我们知道，函数在返回的过程中，会对返回值进行拷贝。因此，一个无法拷贝的对象，是无法被函数返回的。（也可以参考此篇）数组是不能被拷贝的，所以函数无法直接返回数组。为了达到返回数组的目的，我们只能寄希望于让函数返回数组的指针（在 C++ 中还可以返回数组的引用）。 为此我们需要了解如何定义一个返回数组指针的函数。首先，我们来看一组数组的定义： 1234int arr[10]; // arr 是一个数组，长度是 10，元素类型是 int 型int *parr[10]; // parr 是一个指针数组，长度是 10，元素类型是 int *，也就是数组中存的是指针int (*p)[10] = &amp;arr; // p 是一个指针，它指向一个长度是 10 元素类型是 int 型的数组 这样一来就不难构造返回数组的指针的函数定义了 12345678int *(func(param_list))[10]; // 错误：func 是一个函数，param_list 是它的参数 // 它尝试返回一个长度为 10，元素类型为 int * 的数组 // 而数组是无法返回的int (*func(param_list))[10]; // 正确：func 是一个函数，param_list 是它的参数 // 它返回的是一个指针 // 这个指针指向了一个长度为 10 元素类型是 int 型的数组 于是我们得到了此类函数定义的一般形式 1element_type (*func(param_list))[dimension] 函数的指针 上文提到，无论是数据（变量）还是指令（函数），都是存放在虚存空间的。因此，既然有变量的指针，那么也一定会有函数的指针。这就是我们这一小节需要讨论的函数指针；这会逐渐引出本文最复杂的话题。 一个函数的类型，取决于它的输入和输出。这也就是说，一个函数的类型，应当包含它的返回值类型和参数列表。比如下面定义的函数，用于比较两个int型数据是否相等（这是一个仅用于示例而没有实际用处的函数）： 1bool isEqual(int, int); 对于一个函数来说，如果你能拿到它的定义，就很容易能取得它的类型：只需要去掉函数名字就可以了。因此，定义一个指向该类型的函数指针，并不困难。 123bool isEqual(int, int);bool (*pfunc)(int, int) = &amp;isEqual; // 定义了一个函数指针，指向 isEqualbool (*pfunc)(int, int) = isEqual; // 一个等价定义 在这里，pfunc就是一个函数指针，它指向一个bool (int, int)类型的函数。也就是说，这类函数接收两个int型的参数，并返回一个bool类型的值。 值得一提的是，当函数名字作为值使用时，它会自动地转换成指针（有点像数组名字，不是吗）。因此，在函数指针的初始化或者复制的过程中，取值运算符是可选的。于是，上述两个定义语句是等价的。另一方面，函数指针作为函数调用使用时，它会自动转换成函数名（有点像数组指针，不是吗）。因此，这种情况下，解引用运算符是可选的。请看下例： 123456bool isEqual(int, int);bool (*pfunc)(int, int) = isEqual;bool res1 = isEqual(1, 2); // 通过原函数名调用bool res2 = (*pfunc)(1, 2); // 一个等价调用：通过函数指针，解引用调用bool res3 = pfunc(1, 2); // 另一个等价调用：函数指针自动转换成函数名 值得一提的是，不同类型的函数的指针之间，不存在任何的类型转换：你不能期待一个接受两个int型参数并返回bool值的函数的指针，经过类型转换，就能接受三个int型的参数。因此，对于重载的同名函数，他们的函数类型是不一样的，因此函数指针也不能是同一个。 将函数指针作为参数传入另一个函数 在传参的过程中（除了 C++ 的传引用），也是伴随着拷贝的过程。因此，一个对象如果不能拷贝，那么它就不能作为参数传入函数。无疑，函数是不能拷贝的，因此你无法将函数作为参数直接传给另一个函数。但是，指针是可以拷贝的，因此，你可以将函数指针作为参数，传给另一个函数。 12345void addIfEqual(int lhs, int rhs, bool pfunc(int, int)); // addIfEqual 的第三个参数是一个函数定义 // 它会自动地转换成一个函数指针的参数void addIfEqual(int lhs, int rhs, bool (*pfunc)(int, int)); // 一个等价定义：显式地注明第三个参数是函数指针 于是你可以这样使用这个函数 1addIfEqual(1, 1, isEqual); 此时，函数名isEqual作为引数被传入，它起到的是「值」的作用。因此，isEqual被自动地转换成指向该函数的指针。 让函数返回一个函数的指针 同样地，与数组类似，虽然我们无法返回一个函数，但是我们可以返回一个函数指针。我们回到 isEqual 的函数指针的定义上来： 1bool (*pfunc)(int, int) = isEqual; 在这里，pfunc是一个指针，它指向了一个函数；该函数接收两个int型参数，并返回一个bool值。因此，仿造之前「返回数组指针的函数的定义形式」，我们不难得出： 1outer_return_type (*func(param_list))(outer_param_list) 这里，func(param_list)是当前需要定义的函数；outer_return_type和outer_param_list分别是当前定义的函数返回的函数指针对应函数的返回值类型和参数列表。 登峰造极的(*(void(*)())0)(); 这恐怕是一个会令所有 C/C++ 程序员战栗不已的函数调用语句。因此，在解释这个语句之前，我愿意先给出它的含义，安抚读者战栗的心灵。它表示：访问内存地址0，将它作为一个参数列表和返回类型均为空的函数，并执行函数调用。（这是一个特殊场景下的函数调用，不用纠结为什么会调用 0 位置上的函数） 类型定义与 C 风格的类型强制转换符 C 风格的类型强制转换符应该不是个稀罕玩意儿。比如(double)a就能将变量a强制转换为double类型。在这个简单的例子里，我们希望能够找到一些朴素的规律，破解这一登峰造极而又令人战栗的函数调用语句。 同样以double类型及相关指针类型为例，我们首先看下面的代码： 12345double a; // 定义了一个 double 型的变量double *b; // 定义了一个 double * 型的变量（double 型的指针）(double) c; // 将变量 c 强制转换为 double 类型(double *) d; // 将变量 d 强制转换为 double * 类型 我们不难发现，类型转换和对应类型的变量定义，有着千丝万缕的联系：首先去掉变量定义语句末尾的分号，然后去掉变量定义语句中的变量名，最后给剩余的部分加上括号——一个 C 风格的类型强制转换符，就得到了。 破解谜题 我们知道void(*pfunc)(); 定义了一个函数指针pfunc，它指向的函数参数列表为空、返回值类型也为空。因此，(void(*)())就是一个 C 风格的类型转换符。 因此，(void(*)())0会将0转换成一个函数指针，然后交给*解引用，最后传入参数（空的参数列表 ()），执行函数调用。 在 C++ 中，这个函数调用应该写作 1(*reinterpret_cast&lt;void(*)()&gt;(0))(); 显而易见，这个写法，相较 C 风格的类型强制转换符，要清晰明朗得多。因此，请不要再吐槽 C++ 风格的强制转换是「语法盐」了。 转载自《C和C++中的指针》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的虚函数和多态]]></title>
    <url>%2F2018%2F01%2F28%2FvirtualFunctionAndPloymorphism%2F</url>
    <content type="text"><![CDATA[面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。 通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而已统一的方式使用他们的对象。 OOP的核心思想是多态性(Ploymorphism)。多态这个词源于希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能够使用这些类型的“多种类型”而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是支持C++语言支持多态性的根本所在。 当我们使用基类的引用或者指针调用基类中定义的一个函数时，我们并不知道该函数真正的作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时彩会决定到底执行哪个版本的函数，判断的依据是引用或者指针所绑定的对象的真实类型。 另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或者非虚函数)调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。 虚函数 虚函数通过virtual关键字来声明。 1234567891011121314151617181920class CPerson&#123; public: virtual void hello()&#123; cout&lt;&lt;"I'm a person."&lt;&lt;endl; &#125;&#125;;class CMan:public CPerson&#123; public: //子类中不用声明virtual void hello()&#123; cout&lt;&lt;"I'm a man."&lt;&lt;endl; &#125;&#125;;int main()&#123; CPerson *p = new CMan(); p-&gt;hello(); //I'm a man. return 0;&#125; 上述代码中，通过基类指针调用虚函数时，子类的同名函数得到了执行。多态在C++中有三种形态： 1.通过基类指针调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。 2.通过基类引用调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。 3.基类或子类的成员函数中调用基类和子类的同名虚函数时，会调用对象的实际类型中的虚函数。 纯虚函数 我们可以在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处。包含纯虚函数的类不允许实例化，称为抽象类。事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。 123456class CPerson&#123; public: virtual void hello() = 0;&#125;;CPerson p; //compile error 注意空方法、纯虚函数、方法声明的区别。类声明中的空方法给出了方法声明+方法定义。只声明但没有定义的方法将会产生链接错误，无论是否被调用过。 访问级别 虚函数的调用会在运行时动态匹配当前类型，然而成员函数的访问性检查是语法检查的一部分，在编译期完成。如果虚函数在父类中是private，即使在子类中是public，也不可以通过父类指针调用它： 12345678910class CPerson&#123; virtual void hello();&#125;;class CMan:public CPerson&#123; public: virtual void hello();&#125;;CPerson *p = new CMan();p-&gt;hello(); //编译出错 虚析构函数 虚函数的机制使得我们可以通过更加通用的基类指针来操作对象。然而使用基类指针来delete对象则面临着问题。 12CPerson *p = new CMan();delete p; 上述代码只会回收CMan中CPerson部分所占用的内存，执行了CPerson的析构函数，却没有执行CMan的虚构函数。解决方法很直观，将析构函数设为virtual。 构造函数不允许是虚函数，编译错。 1234567891011class CPerson&#123; public: virtual ~CPerson()&#123;&#125;;&#125;;class CMan:public CPerson&#123; public: ~CMan()&#123;&#125;;&#125;;CPerson *p = new CMan();delete p; 这样，delete时会先调用~CMan()再调用~CPerson()。 构造函数调用虚函数 当执行构造函数时，当前对象的类型为构造函数所属的类。所以在构造函数中调用虚函数和调用普通函数是一样的，不会动态联编，被调用的函数来自自己或者基类。 123456789101112131415161718192021222324252627282930313233class CPerson&#123; public: virtual void hello()&#123; cout&lt;&lt;"I'm a person."&lt;&lt;endl; &#125; virtual void bye()&#123; cout&lt;&lt;"Bye, person."&lt;&lt;endl; &#125;&#125;;class CMan:public CPerson&#123; public: CMan()&#123; hello(); bye(); &#125; void hello()&#123; cout&lt;&lt;"I'm a man."&lt;&lt;endl; &#125;&#125;;class CReek:public CMan&#123; public: void hello()&#123; cout&lt;&lt;"I'm a reek."&lt;&lt;endl; &#125; void bye()&#123; cout&lt;&lt;"Bye, reek."&lt;&lt;endl; &#125;&#125;;int main()&#123; CReek r; return 0;&#125; 上述的调用结果是： 12I'm a man.Bye, Person. hello和bye都是虚函数，其中hello三个层级都有定义，但被执行的是当前类CMan中的定义；bye在上下两个层级中有定义，被执行的是上一级CPerson中的定义。可见，构造函数执行时当前对象的类型是定义构造函数的类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>虚函数</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Josephus]]></title>
    <url>%2F2017%2F11%2F02%2FJosephus%2F</url>
    <content type="text"><![CDATA[约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。 有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。 问题是，给定了n和k，一开始要站在什么地方才能避免被处决？ 这个问题是以弗拉维奥·约瑟夫斯命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。 简化之后的问题就变成了，n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 一般解法 非常容易想到的方法就是利用环链表来做，构建一个环链表，每个结点的编号为0, 1, … n-1。每次从当前位置向前移动m-1步，然后删除这个结点。最后剩下的结点就是胜利者。 1234567891011121314151617181920212223242526int Josephus(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; list&lt;int&gt; listInt; unsigned i; //初始化链表 for (i = 0; i &lt; n; i++) &#123; listInt.push_back(i); &#125; list&lt;int&gt;::iterator iterCurrent = listInt.begin(); while (listInt.size() &gt; 1) &#123; //前进m-1步 for (i = 0; i &lt; m - 1; i++) &#123; if (++iterCurrent == listInt.end()) iterCurrent = listInt.begin(); &#125; //临时保存删除的节点 list&lt;int&gt;::iterator iterDel = iterCurrent; if (++iterCurrent == listInt.end()) iterCurrent = listInt.begin(); listInt.erase(iterDel); &#125; return *iterCurrent;&#125; 上述方法效率很低，其时间复杂度为O(m*n)。当m和n很大时候，很难在短时间内得出结果，不过好处就是可以给出n-1个人出圈的顺序，只需要在删除之前保存一下。 进阶解法 普通的解法之所以复杂度高，是因为我们不知道哪个节点会保留下来。所以需要不断遍历删除，直到剩下最后一个节点。如果我们不通过遍历，而是直接计算出最后活下来的节点是哪个，就可以降低时间复杂度。 推导过程如下： 如果只剩下一个节点，那么幸存的节点就是该节点，编号为1，Live(1)=1; 如果剩下两个节点，幸存的节点为Live(2); 如果剩下三个节点，幸存的节点为Live(3) ; … 如果剩下i个节点，幸存的节点为Live(i); … 如果剩下n个节点，幸存的节点为Live(n); 我们已知Live(1)=1，如果确定Live(i-1)和Live(i)是什么关系，就可以递归过程求出Live(n) 如果一个节点数为n的链表，编号从头结点到尾节点为1~n，如果删除编号为s的一个节点，剩下的节点编号将会怎么变化？如下图所示 Josephus1 设原链表编号为y，删除一个节点之后的编号为x，那么我们可以得到以下的公式 1y = (x + s -1) % n + 1 因此可以根据Live(i-1)以及被删除的节点编号来求得Live(i)的值，那么现在问题变成了如何求被删除节点的编号 Josephus2 如图所示，对于每一个节点，如果报数值不到m，就会一直报数下去，1n2n~…由图我们可以得到报数值A与编号值B的关系，即 1B = (A - 1) % n + 1 如果报到m，报数的节点就是要删除的节点，那么该节点的编号根据公式可以得出 1s = (m - 1) % n + 1 得到s之后，我们可以通过上面第一步得出的关系 1Live(i) = (Live(i - 1) + s - 1) % i + 1 把s带入之后，两式合并，结果为 1Live(i) = (Live(i - 1) + m - 1) % i + 1 整个过程总结如下： 1、遍历链表，得到链表的节点数n，O(n) 2、根据n和m的值，以及上文推导的Live(i)与Live(i-1)的关系，递归求得幸存节点的编号。该递归是单决策递归且递归为n层，所以时间复杂度为O(n) 3、根据得到的幸存节点的编号，遍历链表找到该节点，O(n) 123456789101112class Solution &#123;public: int LastRemaining_Solution(unsigned int n, unsigned int m) &#123; if(n==0) return -1; if(n==1) return 0; else return (LastRemaining_Solution(n-1,m)+m)%n; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>约瑟夫环</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages+Hexo建立博客]]></title>
    <url>%2F2017%2F10%2F27%2FCreateWebsite%2F</url>
    <content type="text"><![CDATA[之前有用过WordPress直接建站，但是WordPress有两个不好的地方： 1、WordPress是动态的，对于服务器的要求比较高，配置比较低的服务器运行时候会加载很慢。 2、国内想用自己的域名建网站必须要备案，比较麻烦。 恰好听到同学说可以用Hexo和Github Pages来做静态的个人博客。相比WordPress，Hexo+Github Pages可以不用购买服务器，省了一笔钱。其次Hexo是静态的，加载速度很快，很适合个人博客的搭建。 安装环境 要想使用Hexo，首先要在你的电脑上面安装Node.js和Git工具 安装完毕之后，在你想放置网站文件的地方建立一个文件夹。比如 D:/Hexo。进入到文件夹之后使用git工具 123456$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 这里提一下Hexo常用的几个命令： 12345hexo generate(hexo g) 生成静态文件，会在当前目录下生成一个新的public文件夹hexo server(hexo s) 启动本地Web服务，用于博客的预览hexo deploy(hexo d) 部署博客到远端，比如GitHubhexo new "postName" 新建文章，路径在/source/_postshexo new pages "pageName" 新建页面，路径在/source 安装完成之后，就要选择你需要使用的主题了。Hexo有很多主题可以选择，我这里使用的是Next主题。在GitHub上面搜索到项目之后会有很详细的使用说明，这里不再赘述。 关于主题的个性化定制，一般主题会有很多地方可以个性化更改，可以根据官方文档自行更改，或者使用搜索引擎来获取个性化定制的细节，每个主题都不相同。 需要注意的是，更新主题的时候如果是修改了css文件，需要先清除之前生成的缓存文件，不然有可能无法正常生效。 12$ hexo clean$ hexo generate GitHub Pages设置 什么是GitHub Pages GitHub Pages本来是用来介绍托管在Github上面的项目，不过由于空间免费稳定，被很多人拿来搭建个人博客。 每个人只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。可以通过 http://username.github.io 来直接访问你的个人主页。 这里需要特别注意一下，个人网页的网站内容是在master分支下面的。 配置和使用GitHub Pages 我们如何让本地的项目与远程的Github建立联系呢？一般来说有两种方法。一种是通过GitHub的账号密码来进行操作，第二种是比较推荐，通过SSH keys来建立连接。 检查SSH keys的设置 首先需要检查电脑上现有的SSH key： cd ~/.ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明你第一次使用git，按照下面的步骤创建新的SSH key 123$ ssh-keygen -t rsa -C "邮件地址"Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 然后系统会提示你输入密码： 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入&gt; 添加SSH key到Github 1 在本机设置SSH key之后，需要添加到Github上，已完成SSH链接的设置。 首先打开本地id_rsa.pub文件，(参考地址： C:\Users\yourname.ssh\id_rsa.pub)。文件内容为刚才生成的密钥，复制文件内容。 2 登陆Github，点击右上角Settings-&gt;SSH and GPG keys 。新建SSH keys，内容为刚才复制的密钥内容。 3 测试下面的命令，看是否成功，命令不要更改 $ ssh -T git@GitHub.com 如果看到如下反馈 123The authenticity of host 'GitHub.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入 yes 就好，然后会看到成功的信息。 有的时候会提示permission denied，此时一般是ssh公钥没有添加到本地SSH环境中，只需要使用ssh-add命令添加公钥即可。 1ssh-add your_publickey 设置用户信息 现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。 Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 12$ git config --global user.name "username"//用户名$ git config --global user.email "username@gmail.com"//填写自己的邮箱 域名 上面已经完成了基本环境的设置，但是搭建个人博客，最重要的是要有一个自己的域名。这里域名推荐去Godaddy上面购买，选好自己喜欢的域名之后，建立解析即可。注意，域名解析要建立两个A的解析记录，分别为192.30.252.154和192.30.252.153。然后建立一个CNAME类型的解析，主机记录设置为www，记录值设置为你的Github Pages的网址，比如yourname.github.io。 做完上面的步骤，其实还是不能直接通过自己的域名去访问Github Pages的。还需要两个小步骤的设置： 先进入Github，进入Github Pages的仓库，然后找到Settings-&gt;Options-&gt;GitHub Pages 找到Custom domain，把你设置的个人域名添加进去。 然后在仓库的根目录添加一个CNAME文件，文件内容为你的域名 完成上面的设置，已经可以成功通过自己的域名访问 把博客部署到Github 前面我们已经完成了所有的基础设置，并且已经可以在本地访问自己的博客，下面我们需要完成的就是把本地的博客部署到Github上面。Hexo提供了deploy插件让我们使用，方便部署到很多平台。如果部署到Github，需要先安装扩展 $ npm install hexo-deployer-git --save 然后在配置文件_config.xml中做下面的修改： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git //可以在项目仓库clone看到地址 branch: master 然后再执行 hexo d 就能完成部署，这时通过你的域名就能直接访问博客了。 参考链接 手把手教你使用Hexo + Github Pages搭建个人独立博客 MarkDown语法说明(简体中文版) hexo的next主题个性化配置教程 Hexo Markdown 简明语法手册]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
</search>
