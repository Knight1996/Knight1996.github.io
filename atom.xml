<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>knightyui&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.knightyui.com/"/>
  <updated>2018-07-29T12:39:07.921Z</updated>
  <id>https://blog.knightyui.com/</id>
  
  <author>
    <name>knightyui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ string使用</title>
    <link href="https://blog.knightyui.com/2018/04/30/stringInCpp/"/>
    <id>https://blog.knightyui.com/2018/04/30/stringInCpp/</id>
    <published>2018-04-30T07:59:20.000Z</published>
    <updated>2018-07-29T12:39:07.921Z</updated>
    
    <content type="html"><![CDATA[<p>string 是C++ 标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时 C++ 的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。<a id="more"></a></p><h1 id="声明和初始化"><a class="markdownIt-Anchor" href="#声明和初始化"></a> 声明和初始化</h1><p>想使用string首先要在头文件中加入<code>&lt;string&gt;</code><br>声明方式也很简单</p><h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a;       <span class="comment">//声明一个string对象</span></span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">10</span>];  <span class="comment">//声明一个string对象的数组</span></span><br></pre></td></tr></table></figure><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><p>使用等号的初始化叫做拷贝初始化，不用等号的初始化叫做直接初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;                   <span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;          <span class="comment">//s1是字面值"ssss"的副本</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;              <span class="comment">//s2是s1的副本</span></span><br><span class="line">    <span class="built_in">string</span> s3 = s2;             <span class="comment">//s3是s2的副本</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;         <span class="comment">//把s4初始化，十个'c' </span></span><br><span class="line">    <span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;         <span class="comment">//拷贝初始化</span></span><br><span class="line">    <span class="built_in">string</span> s6 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string s(cp, n)</span></span><br><span class="line">    <span class="keyword">char</span> cs[] = <span class="string">"12345"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(cs, <span class="number">3</span>)</span></span>;           <span class="comment">//复制字符串cs的前三个字符到s当中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string s(s2, pos2)</span></span><br><span class="line">    <span class="built_in">string</span> s8 = <span class="string">"asac"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s9</span><span class="params">(s8, <span class="number">2</span>)</span></span>;           <span class="comment">//从s2的第二个字符开始拷贝，不能超过s2的zise</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string s(s2, pos2, len2)</span></span><br><span class="line">    <span class="built_in">string</span> s10 = <span class="string">"qerqfdsdfa"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s11</span><span class="params">(s10, <span class="number">3</span>, <span class="number">4</span>)</span></span>;      <span class="comment">//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串处理"><a class="markdownIt-Anchor" href="#字符串处理"></a> 字符串处理</h1><h2 id="substr操作"><a class="markdownIt-Anchor" href="#substr操作"></a> substr操作</h2><p>注意substr没有迭代器作为参数的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.substr(pos, n) 返回字符串位置味pos1后面的n个字符组成的串，pos从0开始</span></span><br><span class="line">    <span class="built_in">string</span> s2 = s.substr(<span class="number">1</span>, <span class="number">5</span>);     <span class="comment">//bcdef</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.substr(pos) 得到一个pos到结尾的串 pos从0开始</span></span><br><span class="line">    <span class="built_in">string</span> s3 = s.substr(<span class="number">4</span>)         <span class="comment">//efg</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的位置超过字符的长度，会抛出一个 out_of_range 的异常</p><h2 id="insert操作"><a class="markdownIt-Anchor" href="#insert操作"></a> insert操作</h2><p>注意用迭代器当参数和无符号数当参数的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"to be question"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"the "</span>;</span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">"or not to be"</span>;</span><br><span class="line">    <span class="built_in">string</span>::iterator it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(pos, str) 在s的pos位置插入str</span></span><br><span class="line">    str.insert(<span class="number">6</span>, str2);                 <span class="comment">// to be the question</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(pos, str, a, n) 在s的pos位置插入str中插入位置a到后面的n个字符</span></span><br><span class="line">    str.insert(<span class="number">6</span>, str3, <span class="number">3</span>, <span class="number">4</span>);             <span class="comment">// to be not the question</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(pos, cstr, n)//在pos位置插入cstr字符串从开始到后面的n个字符</span></span><br><span class="line">    str.insert(<span class="number">10</span>, <span class="string">"that is cool"</span>, <span class="number">8</span>);    <span class="comment">// to be not that is the question</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(pos, cstr)在s的pos位置插入cstr</span></span><br><span class="line">    str.insert(<span class="number">10</span>, <span class="string">"to be "</span>);            <span class="comment">// to be not to be that is the question</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(pos, n, ch)在s.pos位置上面插入n个ch</span></span><br><span class="line">    str.insert(<span class="number">15</span>, <span class="number">1</span>, <span class="string">':'</span>);               <span class="comment">// to be not to be: that is the question</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(s.it, ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</span></span><br><span class="line">    it = str.insert(str.begin() + <span class="number">5</span>, <span class="string">','</span>); <span class="comment">// to be, not to be: that is the question</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(s.it, n, ch)//在s的it所指向位置的前面插入n个ch</span></span><br><span class="line">    str.insert (str.end(), <span class="number">3</span>, <span class="string">'.'</span>);       <span class="comment">// to be, not to be: that is the question...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.insert(it, str.ita, str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</span></span><br><span class="line">    str.insert (it+<span class="number">2</span>, str3.begin(), str3.begin()+<span class="number">3</span>); <span class="comment">// to be, or not to be: that is the question...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="erase操作"><a class="markdownIt-Anchor" href="#erase操作"></a> erase操作</h2><p>用来执行删除操作<br>删除操作共有三种</p><ul><li>指定pos和len，其中pos为起始位置，pos以及后面len - 1个字符都删除</li><li>迭代器，删除迭代器指向的字符</li><li>迭代器范围，删除这一范围内的字符串，范围左闭右开</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span> <span class="params">(<span class="string">"This is an example sentence."</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// "This is an example sentence."</span></span><br><span class="line">                                <span class="comment">//            ^^^^^^^^</span></span><br><span class="line">    str.erase (<span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//直接指定删除的字符串位置第十个后面的8个字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// "This is an sentence."</span></span><br><span class="line">                                <span class="comment">//           ^</span></span><br><span class="line">    str.erase (str.begin() + <span class="number">9</span>);</span><br><span class="line">    <span class="comment">//删除迭代器指向的字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// "This is a sentence."</span></span><br><span class="line">                                <span class="comment">//       ^^^^^</span></span><br><span class="line">    str.erase (str.begin() + <span class="number">5</span>, str.end() - <span class="number">9</span>);</span><br><span class="line">    <span class="comment">//删除迭代器范围的字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// "This sentence."</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append和replace操作"><a class="markdownIt-Anchor" href="#append和replace操作"></a> append和replace操作</h2><p>append函数可以用来在字符串末尾追加字符和字符串。由于string重载了运算符，也可以用 += 操作实现<br>replace顾名思义，就是替换的意思，先删除，后增加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"Writing "</span>;</span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">"print 10 and then 5 more"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接追加一个str2的字符串</span></span><br><span class="line">    str.append(str2);                       <span class="comment">// "Writing "</span></span><br><span class="line">    <span class="comment">//后面追加str3第6个字符开始的3个字符串</span></span><br><span class="line">    str.append(str3, <span class="number">6</span>, <span class="number">3</span>);                   <span class="comment">// "10 "</span></span><br><span class="line">    <span class="comment">//追加字符串形参的前5个字符</span></span><br><span class="line">    str.append(<span class="string">"dots are cool"</span>, <span class="number">5</span>);          <span class="comment">// "dots "</span></span><br><span class="line">    <span class="comment">//直接添加</span></span><br><span class="line">    str.append(<span class="string">"here: "</span>);                   <span class="comment">// "here: "</span></span><br><span class="line">    <span class="comment">//添加10个'.'</span></span><br><span class="line">    str.append(<span class="number">10</span>, <span class="string">'.'</span>);                    <span class="comment">// ".........."</span></span><br><span class="line">    <span class="comment">//添加str3迭代器范围的字符串</span></span><br><span class="line">    str.append(str3.begin() + <span class="number">8</span>, str3.end());  <span class="comment">// " and then 5 more"</span></span><br><span class="line">    <span class="comment">//最后这个比较特殊，意思是添加5个'A'，实际上参数里面的65对应的asc码就是65</span></span><br><span class="line">    str.append&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">65</span>);                <span class="comment">// "....."</span></span><br><span class="line">    <span class="comment">//字符串追加也可以用重载运算符实现</span></span><br><span class="line">    str += <span class="string">"lalala"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> base = <span class="string">"this is a test string."</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"n example"</span>;</span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">"sample phrase"</span>;</span><br><span class="line">    <span class="built_in">string</span> str4 = <span class="string">"useful."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace signatures used in the same order as described above:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using positions:                 0123456789*123456789*12345</span></span><br><span class="line">    <span class="built_in">string</span> str = base;                  <span class="comment">// "this is a test string."</span></span><br><span class="line">    <span class="comment">//第9个字符以及后面的4个字符被str2代替</span></span><br><span class="line">    str.replace(<span class="number">9</span>, <span class="number">5</span>, str2);            <span class="comment">// "this is an example string." (1)</span></span><br><span class="line">    <span class="comment">//第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</span></span><br><span class="line">    str.replace(<span class="number">19</span>, <span class="number">6</span>, str3, <span class="number">7</span>, <span class="number">6</span>);     <span class="comment">// "this is an example phrase." (2)</span></span><br><span class="line">    <span class="comment">//第8个字符以及后面的9个字符用字符串参数代替</span></span><br><span class="line">    str.replace(<span class="number">8</span>, <span class="number">10</span>, <span class="string">"just a"</span>);       <span class="comment">// "this is just a phrase."     (3)</span></span><br><span class="line">    <span class="comment">//第8个字符以及后面的5个字符用字符串参数的前7个字符替换</span></span><br><span class="line">    str.replace(<span class="number">8</span>, <span class="number">6</span>, <span class="string">"a shorty"</span>, <span class="number">7</span>);   <span class="comment">// "this is a short phrase."    (4)</span></span><br><span class="line">    <span class="comment">//第22以及后面的0个字符用3个叹号替换</span></span><br><span class="line">    str.replace(<span class="number">22</span>, <span class="number">1</span>,  <span class="number">3</span>, <span class="string">'!'</span>);        <span class="comment">// "this is a short phrase!!!"  (5)</span></span><br><span class="line">    <span class="comment">//迭代器的原理同上</span></span><br><span class="line">    <span class="comment">// Using iterators:                                               0123456789*123456789*</span></span><br><span class="line">    str.replace(str.begin(), str.end()<span class="number">-3</span>, str3);                        <span class="comment">// "sample phrase!!!"      (1)</span></span><br><span class="line">    str.replace(str.begin(), str.begin() + <span class="number">6</span>,<span class="string">"replace"</span>);                <span class="comment">// "replace phrase!!!"     (3)</span></span><br><span class="line">    str.replace(str.begin() + <span class="number">8</span>, str.begin() + <span class="number">14</span>, <span class="string">"is coolness"</span>, <span class="number">7</span>);   <span class="comment">// "replace is cool!!!"    (4)</span></span><br><span class="line">    str.replace(str.begin() + <span class="number">12</span>, str.end() - <span class="number">4</span>, <span class="number">4</span>, <span class="string">'o'</span>);               <span class="comment">// "replace is cooool!!!"  (5)</span></span><br><span class="line">    str.replace(str.begin() + <span class="number">11</span>, str.end(), str4.begin(), str4.end()); <span class="comment">// "replace is useful."    (6)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="assign操作"><a class="markdownIt-Anchor" href="#assign操作"></a> assign操作</h2><p>assign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">string</span> base = <span class="string">"The quick brown fox jumps over a lazy dog."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// used in the same order as described above:</span></span><br><span class="line">    <span class="comment">//直接把base赋值给str</span></span><br><span class="line">    str.assign(base);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//把base第10个字符以及后面的8个字符赋给str</span></span><br><span class="line">    str.assign(base, <span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// "brown fox"</span></span><br><span class="line">    <span class="comment">//把参数中的0到6个字符串赋给str</span></span><br><span class="line">    str.assign(<span class="string">"pangrams are cool"</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// "pangram"</span></span><br><span class="line">    <span class="comment">//直接使用参数赋值</span></span><br><span class="line">    str.assign(<span class="string">"c-string"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// "c-string"</span></span><br><span class="line">    <span class="comment">//给str赋值10个'*'字符</span></span><br><span class="line">    str.assign(<span class="number">10</span>, <span class="string">'*'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// "**********"</span></span><br><span class="line">    <span class="comment">//赋值是10个'-'</span></span><br><span class="line">    str.assign&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">0x2D</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// "----------"</span></span><br><span class="line">    <span class="comment">//指定base迭代器范围的字符串</span></span><br><span class="line">    str.assign(base.begin() + <span class="number">16</span>, base.end() - <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// "fox jumps over"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string的搜索操作"><a class="markdownIt-Anchor" href="#string的搜索操作"></a> string的搜索操作</h1><p>string类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。</p><h2 id="find和rfind函数"><a class="markdownIt-Anchor" href="#find和rfind函数"></a> find和rfind函数</h2><p>find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span> <span class="params">(<span class="string">"There are two needles in this haystack with needles."</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span> <span class="params">(<span class="string">"needle"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// different member versions of find in the same order as above:</span></span><br><span class="line">    <span class="comment">//在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</span></span><br><span class="line">    <span class="keyword">size_t</span> found = str.find(str2);      <span class="comment">//注意size_t</span></span><br><span class="line">    <span class="keyword">if</span> (found! = <span class="built_in">string</span>::npos)          <span class="comment">//string::npos指string的结束位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first 'needle' found at: "</span> &lt;&lt; found &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//在str当中，从第found+1的位置开始查找参数字符串的前6个字符</span></span><br><span class="line">    found = str.find(<span class="string">"needles are small"</span>, found + <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"second 'needle' found at: "</span> &lt;&lt; found &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//在str当中查找参数中的字符串</span></span><br><span class="line">    found = str.find(<span class="string">"haystack"</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"'haystack' also found at: "</span> &lt;&lt; found &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//查找一个字符</span></span><br><span class="line">    found = str.find(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Period found at: "</span> &lt;&lt; found &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//组合使用，把str2用参数表中的字符串代替</span></span><br><span class="line">    <span class="comment">// let's replace the first needle:</span></span><br><span class="line">    str.replace(str.find(str2), str2.length(), <span class="string">"preposition"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span> <span class="params">(<span class="string">"The sixth sick sheik's sixth sheep's sick."</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">key</span> <span class="params">(<span class="string">"sixth"</span>)</span></span>;<span class="comment">//                    ^</span></span><br><span class="line">    <span class="comment">//rfind是找最后一个出现的匹配字符串</span></span><br><span class="line">    <span class="keyword">size_t</span> found = str.rfind(key);</span><br><span class="line">    <span class="keyword">if</span>(found != <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; found &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出23</span></span><br><span class="line">        str.replace(found, key.length(), <span class="string">"seventh"</span>);<span class="comment">//找到的sixth替换成seventh</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find__of函数"><a class="markdownIt-Anchor" href="#find__of函数"></a> find_…_of函数</h2><ul><li>find_first_of(args) 查找args中任何一个字符第一次出现的位置</li><li>find_last_of(args) 最后一个出现的位置</li><li>find_fist_not_of(args) 查找第一个不在args中的字符</li><li>find_last_not_of 查找最后一个不在args中出现的字符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str1</span> <span class="params">(<span class="string">"Please, replace the vowels in this sentence by asterisks."</span>)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> found1 = str1.find_first_of(<span class="string">"aeiou"</span>);</span><br><span class="line">    <span class="comment">//把所有元音找出来用*代替</span></span><br><span class="line">    <span class="keyword">while</span> (found1 != <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[found1] = <span class="string">'*'</span>;</span><br><span class="line">        found1 = str1.find_first_of(<span class="string">"aeiou"</span>,found1 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在str2中找到第一个不是消协英文字母和空格的字符</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span> <span class="params">(<span class="string">"look for non-alphabetic characters..."</span>)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> found2 = str2.find_first_not_of(<span class="string">"abcdefghijklmnopqrstuvwxyz "</span>);</span><br><span class="line">    <span class="keyword">if</span> (found2 != <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first non-alphabetic character is "</span> &lt;&lt; str2[found2];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" at position "</span> &lt;&lt; found2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find_last_of和find_last_not_of与first基本相同。</p><h1 id="比较与转换"><a class="markdownIt-Anchor" href="#比较与转换"></a> 比较与转换</h1><p>类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。</p><h2 id="compare函数"><a class="markdownIt-Anchor" href="#compare函数"></a> compare函数</h2><p>和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。<br>在compare当中还支持部分比较，里面有6个参数可以设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"123"</span>, s2 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.compare(s2) &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    s1 = <span class="string">"123"</span>, s2 = <span class="string">"1234"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.compare(s2) &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">    s1 = <span class="string">"1234"</span>, s2 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.compare(s2) &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str1</span> <span class="params">(<span class="string">"green apple"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span> <span class="params">(<span class="string">"red apple"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1.compare(str2) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">" is not "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//str1的第6个字符以及后面的4个字符和参数比较</span></span><br><span class="line">    <span class="keyword">if</span> (str1.compare(<span class="number">6</span>,<span class="number">5</span>,<span class="string">"apple"</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"still, "</span> &lt;&lt; str1 &lt;&lt; <span class="string">" is an apple"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str2.compare(str2.size() - <span class="number">5</span>, <span class="number">5</span>, <span class="string">"apple"</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"and "</span> &lt;&lt; str2 &lt;&lt; <span class="string">" is also an apple"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较</span></span><br><span class="line">    <span class="keyword">if</span> (str1.compare(<span class="number">6</span>, <span class="number">5</span>, str2, <span class="number">4</span>, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"therefore, both are apples"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于string重载了运算符，可以直接用&gt;,&lt;，==来进行比较，也很方便。</p><h1 id="数值转换"><a class="markdownIt-Anchor" href="#数值转换"></a> 数值转换</h1><p>在IO的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。</p><table><thead><tr><th style="text-align:left">string和数值转换</th><th style="text-align:right"></th></tr></thead><tbody><tr><td style="text-align:left">to_string(val)</td><td style="text-align:right">把val转换成string</td></tr><tr><td style="text-align:left">stoi(s, p, b)</td><td style="text-align:right">把字符串s从p开始转换成b进制的int</td></tr><tr><td style="text-align:left">stol(s, p, b)</td><td style="text-align:right">把字符串s从p开始转换成b进制的long</td></tr><tr><td style="text-align:left">stoul(s, p, b)</td><td style="text-align:right">把字符串s从p开始转换成b进制的unsigned long</td></tr><tr><td style="text-align:left">stoll(s, p, b)</td><td style="text-align:right">long long</td></tr><tr><td style="text-align:left">stoull(s, p, b)</td><td style="text-align:right">unsigned long long</td></tr><tr><td style="text-align:left">stof(s, p)</td><td style="text-align:right">float</td></tr><tr><td style="text-align:left">stod(s, p)</td><td style="text-align:right">double</td></tr><tr><td style="text-align:left">stold(s, p)</td><td style="text-align:right">long double</td></tr></tbody></table><p>注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1;</span><br><span class="line">    s1 = to_string(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a = stoi(s1, <span class="number">0</span>, <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转载自<a href="https://blog.csdn.net/tengfei461807914/article/details/52203202" target="_blank" rel="noopener">C++ string的用法和例子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;string 是C++ 标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时 C++ 的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。
    
    </summary>
    
      <category term="技术" scheme="https://blog.knightyui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://blog.knightyui.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Docker简介及使用</title>
    <link href="https://blog.knightyui.com/2018/03/27/docker-tutorial/"/>
    <id>https://blog.knightyui.com/2018/03/27/docker-tutorial/</id>
    <published>2018-03-27T10:28:20.000Z</published>
    <updated>2018-07-29T12:39:07.921Z</updated>
    
    <content type="html"><![CDATA[<p>Docker，这个名词第一次听到是从浩哥那里。大概是去年秋天的时候，浩哥让我在服务器上使用docker撘一个内网穿透frp服务器，用来做树莓派的公网访问。后来由于不再使用树莓派也没有再继续了解下去。最近在V站也经常看到关于Docker的帖子，看起来还是蛮有用的，先挖个坑，毕业之前补完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker，这个名词第一次听到是从浩哥那里。大概是去年秋天的时候，浩哥让我在服务器上使用docker撘一个内网穿透frp服务器，用来做树莓派的公网访问。后来由于不再使用树莓派也没有再继续了解下去。最近在V站也经常看到关于Docker的帖子，看起来还是蛮有用的，先挖个坑，毕
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.knightyui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://blog.knightyui.com/tags/docker/"/>
    
      <category term="Linux" scheme="https://blog.knightyui.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客GitHub备份，还有一些常用Git操作</title>
    <link href="https://blog.knightyui.com/2018/03/25/BackUpHexoAndGit/"/>
    <id>https://blog.knightyui.com/2018/03/25/BackUpHexoAndGit/</id>
    <published>2018-03-24T17:30:32.000Z</published>
    <updated>2018-08-10T14:33:57.220Z</updated>
    
    <content type="html"><![CDATA[<p>年后换了电脑，博客的文件也从旧电脑转到了新的电脑上面，但是总觉得这种方式很不方便，把文件拷来拷去。<br><br>由于博客是发布在GitHubPages上的，就想能不能把博客的生成文件也传到GitHub上。但是这样又出现一个新的问题，一个博客我要用两个仓库来存。突然想起来Git的branch，这岂不是正好用来存储源文件和生成的静态文件？<a id="more"></a><br>首先在仓库新建一个Branch，我这里就直接命名为Hexo了，作为Hexo源文件的备份分支。然后把这个分支设置为默认分支，这样写完博客之后直接把源文件git push到GitHub的仓库中，再也不怕硬盘坏掉或者换电脑了。需要这些源文件的时候git clone下来，然后依次执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hexo-cli</span><br><span class="line">npm <span class="keyword">install</span> hexo</span><br><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><p>这样环境就跟之前一模一样了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/BackUpHexoAndGit/hexo-backup.png" alt="branch" title="">                </div>                <div class="image-caption">branch</div>            </figure><p>最近也在学习使用Git了，这个工具真的很强大，后悔没有早点开始使用，在自己的服务器上也搭建了一个Git仓库，记录一些常用的命令：<br>一般来说日常使用只需要记住下图六个命令。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/BackUpHexoAndGit/GitCommand.png" alt="GitCommand" title="">                </div>                <div class="image-caption">GitCommand</div>            </figure><p>下面是常用的Git命令清单：</p><h1 id="新建代码仓库"><a class="markdownIt-Anchor" href="#新建代码仓库"></a> 新建代码仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [curl]</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git<span class="built_in"> config </span>--list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git<span class="built_in"> config </span>-e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时用户信息</span></span><br><span class="line">git<span class="built_in"> config </span>[--global] user.name <span class="string">"name"</span></span><br><span class="line">git<span class="built_in"> config </span>[--global] user.email <span class="string">"eamil_adress"</span></span><br></pre></td></tr></table></figure><h1 id="增加删除文件"><a class="markdownIt-Anchor" href="#增加删除文件"></a> 增加/删除文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h1 id="代码提交"><a class="markdownIt-Anchor" href="#代码提交"></a> 代码提交</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h1 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h1 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h1 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h1 id="远程同步"><a class="markdownIt-Anchor" href="#远程同步"></a> 远程同步</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改一个远程仓库的URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote <span class="built_in">set</span>-url [remote] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rm [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h1 id="撤销"><a class="markdownIt-Anchor" href="#撤销"></a> 撤销</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git命令清单</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年后换了电脑，博客的文件也从旧电脑转到了新的电脑上面，但是总觉得这种方式很不方便，把文件拷来拷去。&lt;br&gt;&lt;br&gt;
由于博客是发布在GitHubPages上的，就想能不能把博客的生成文件也传到GitHub上。但是这样又出现一个新的问题，一个博客我要用两个仓库来存。突然想起来Git的branch，这岂不是正好用来存储源文件和生成的静态文件？
    
    </summary>
    
      <category term="技术" scheme="https://blog.knightyui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.knightyui.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://blog.knightyui.com/tags/GitHub/"/>
    
      <category term="Git" scheme="https://blog.knightyui.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C++中的指针</title>
    <link href="https://blog.knightyui.com/2018/01/30/pointInCPP/"/>
    <id>https://blog.knightyui.com/2018/01/30/pointInCPP/</id>
    <published>2018-01-30T11:08:33.000Z</published>
    <updated>2018-07-29T12:39:07.921Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>指针是C语言的大杀器<br></p></blockquote><p>C++中的指针，是语言中相当犀利的工具。但它也是一把双刃剑，用得不好就是毁灭整个工程的大杀器。<a id="more"></a></p><h1 id="数据-指令和内存"><a class="markdownIt-Anchor" href="#数据-指令和内存"></a> 数据、指令和内存</h1><p>在冯诺依曼体系中，程序的数据和指令是存放在同一空间中的。在Linux中，它们存放在进程的虚拟内存空间中。(相关内容可以参考<a href="https://liam0205.me/2016/08/30/review-of-hardware-development/" target="_blank" rel="noopener">程序员的自我修养：一</a>、<a href="https://liam0205.me/2016/05/01/Introduction-to-Memory-Addressing/" target="_blank" rel="noopener">二</a>、<a href="https://liam0205.me/2017/01/17/fork-safe/" target="_blank" rel="noopener">三</a>)因此，对于进程来说，数据和指令并没有本质的差别；其区别仅在于如何理解和使用虚拟内存空间中的内容。如果读取虚拟内存空间某个位置的值来使用，这块内容就是数据，如果执行虚拟内存空间某个位置的代码，这块内容就是指令。决定如何理解和使用虚拟内存空间中的内容的因素，是类型。具体到C和C++语言来说，对应数据的那部分内存，当中存储的自然就是数据；对应函数的那部分内存，当中存储的就是指令。</p><p>因此，对于虚拟内存空间中的内容来说，有两个关键要素：</p><ul><li>它在哪里(内存地址是多少)</li><li>它具有哪些属性，能做哪些事情(它的类型是什么)</li></ul><h1 id="指针是对内存区域的抽象"><a class="markdownIt-Anchor" href="#指针是对内存区域的抽象"></a> 指针是对内存区域的抽象</h1><p>C++中的指针，是一种特殊的复合类型。指针变量中存放着目标对象的内存地址，而与指针相符合的类型，则说明了相应内存区域中的内容有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本是不可解读的，但是如果有一个描述这块内存区域的指针存在，我们就能找到它(地址的作用)，并且合理地使用它(类型的作用)。因此我们说：<strong>指针是对内存区域的抽象</strong>。</p><h1 id="定义和使用指针"><a class="markdownIt-Anchor" href="#定义和使用指针"></a> 定义和使用指针</h1><h2 id="指针的定义"><a class="markdownIt-Anchor" href="#指针的定义"></a> 指针的定义</h2><p>在C++中定义指针变量是很简单的。和定义普通的变量基本是一样的，区别仅在于我们需要在变量名称前使用 <strong>解引用符号</strong> <code>*</code>来标记这是一个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip1, *ip2;     <span class="comment">//ip1 和 ip2 都是指向 int 类型变量的指针变量</span></span><br><span class="line"><span class="keyword">double</span> d, *dp;      <span class="comment">//d 是 double 类型变量， dp 是指向 double 类型变量的指针变量</span></span><br></pre></td></tr></table></figure><p>在上述定义中，我们看到<code>ip1</code> <code>ip2</code> <code>dp</code>是三个指针，因为在塔门之前用<code>*</code>标记它们是指针。而<code>d</code>是一个普通的<code>double</code>类型变量。同时我们注意到，<code>ip1</code> <code>ip2</code>在定义之时就确定了它们是指向<code>int</code>类型的变量。这意味着被<code>ip1</code> <code>ip2</code>指向的内存， <strong>在使用<code>ip1</code>和<code>ip2</code>进行访问时，将被当做<code>int</code>类型的对象来对待。</strong> 同理，<code>dp</code>指向的内存，在使用<code>dp</code>进行访问的时候，将被当做是<code>double</code>类型的对象来对待。</p><p>在之前我们提到，内存空间中的内容有两个关键要素：地址和类型。在上述定义过程中，我们通过类型与解引用符号<code>*</code>相结合，已经确定了类型，如果要正确使用指针，我们还应该让指针记录一个地址。</p><h2 id="获取对象的地址"><a class="markdownIt-Anchor" href="#获取对象的地址"></a> 获取对象的地址</h2><p>上面说到，我们在定义指针之后，记录一个地址。在C++中，我们需要使用 <strong>取地址符号<code>&amp;</code></strong> 来获取对象的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;      <span class="comment">//&amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里</span></span><br></pre></td></tr></table></figure><p>绝大多数情况下，指针的类型和对象的类型需要严格匹配。例如，你不能使用一个指向<code>int</code>类型的指针变量保存一个<code>double</code>类型的对象的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> *pd1 = &amp;dval;    <span class="comment">// 正确：pd1 保存 double 类型变量 dval 的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd1;      <span class="comment">// 正确：pd1 是 double 类型的指针，可以赋值初始化同样类型的 pd2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;dval;       <span class="comment">// 错误：不能用指向 int 类型变量的指针保存 double 类型变量的地址</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = pd1;         <span class="comment">// 错误：pd1 是 double 类型的指针，不能将其赋值给 int 类型的指针</span></span><br></pre></td></tr></table></figure><h2 id="访问指针指向的对象"><a class="markdownIt-Anchor" href="#访问指针指向的对象"></a> 访问指针指向的对象</h2><p>在下例中，指针<code>p</code>记录了变量<code>val</code>的地址。因此，我们可以通过解引用指针<code>p</code>来访问变量<code>val</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p  = &amp;val;         <span class="comment">// &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 通过指针 p 访问变量 val，输出 val 的值：42</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">360</span>;               <span class="comment">// 通过指针 p 改变变量 val 的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 通过指针 p 访问变量 val，输出 val 的值：360</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 输出 val 的值：360</span></span><br></pre></td></tr></table></figure><h2 id="空指针和空类型的指针"><a class="markdownIt-Anchor" href="#空指针和空类型的指针"></a> 空指针和空类型的指针</h2><p>空指针是不指向任何对象的指针，在实际编程中，通常使用空指针作为指针变量有效性的判断标准。<br>C 语言和老版本 C++ 的空指针字面值是<code>NULL</code>，它定义在<code>stdlib</code>当中；新版本的 C++ 使用<code>nullptr</code>作为空指针字面值。C++ 还支持用字面值常量<code>0</code>初始化指针变量，被这样初始化的指针变量会是一个空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>;         <span class="comment">// C 风格的空指针初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">nullptr</span>;      <span class="comment">// C++ 风格的空指针初始化</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="number">0</span>;            <span class="comment">// 使用字面值常量 0 初始化空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == p1) &#123;    <span class="comment">// 思考一下为什么不是 p1 == nullptr</span></span><br><span class="line">    ; <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空类型的指针，指的是形如<code>void *pv</code>的指针。这是一类特殊的指针；这里的空类型，不是说没有类型，而是说空类型的指针，可以用于存储任意类型对象的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;pi;     <span class="comment">// 使用 void * 存放了一个 double 类型对象的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd = &amp;pi;</span><br><span class="line">pd = pv;            <span class="comment">// 错误：不能将空类型的指针赋值给其他类型的指针</span></span><br><span class="line">pv = pd;            <span class="comment">// 正确：空类型的指针可以接受任意类型的指针赋值</span></span><br><span class="line">pd = (<span class="keyword">double</span> *)pv;  <span class="comment">// 正确：C 风格的强制类型转换</span></span><br><span class="line">pd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(pv); <span class="comment">// 正确：C++ 风格的强制类型转换</span></span><br></pre></td></tr></table></figure><p>让我们回顾一下指针的两个要素：地址和类型。由于空类型的指针可以接受任意类型对象的地址，所以，当编译器拿到一个空类型的指针的时候，它无法知道应该按照何种方式解释和使用指针中记录地址中的内容。因此，空类型指针能够做的事情非常有限：做指针之间的比较、作为函数的输入或输出、赋值给另外一个空类型指针。</p><h1 id="理解指针的定义"><a class="markdownIt-Anchor" href="#理解指针的定义"></a> 理解指针的定义</h1><h2 id="再探变量声明"><a class="markdownIt-Anchor" href="#再探变量声明"></a> 再探变量声明</h2><p>在 C 和 C++ 中，变量的声明包括一个基本数据类型（或者类类型），以及一组声明符。定义指针使用的解引用符号<code>*</code>是类型修饰符，它是声明符的一部分。因此，在下列语句中，<code>int</code>是基本数据类型，<code>*p</code>是声明符,<code>*</code>是类型修饰符作为声明符的一部分存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure><p>在同一个变量定义语句中，基本数据类型只能有一个，但是可以有多个形式相同或不同的声明符。这也就是说，同一个语句可以定义出不同类型的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pi 是指向 int 型变量的指针；val 是 int 型变量</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="literal">nullptr</span>,</span><br><span class="line">    val = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h2 id="理解稍微复杂的指针定义"><a class="markdownIt-Anchor" href="#理解稍微复杂的指针定义"></a> 理解稍微复杂的指针定义</h2><p>因为指针本身也是变量，所以它当然也是存储在虚存空间里的。因此，我们当然也可以定义一个指向这一指针的指针。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"><span class="keyword">int</span> **pp = &amp;p;</span><br></pre></td></tr></table></figure><p>我们需要仔细理解一下<code>pp</code>的定义。理解这类稍微复杂的定义语句，一个基本的办法就是：从最靠近变量名字的地方开始，一层一层剖析变量的类型。我们来看</p><ul><li>距离<code>pp</code>最近的是一个解引用符<code>*</code>，这预示着<code>pp</code>是一个指针，它指向<code>int *</code>类型的变量；</li><li>再来看<code>int *</code>，距离<code>*pp</code>最近的，依然是一个解引用符，这意味着<code>*pp</code>也是一个指针，它指向<code>int</code>类型的变量；</li><li>因此<code>pp</code>是一个指向指向<code>int</code>类型变量的指针的指针</li></ul><h2 id="const与指针"><a class="markdownIt-Anchor" href="#const与指针"></a> <code>const</code>与指针</h2><p>常量的值在生存期内不允许改变。这一特性经常是有用的：可以定义一个常量，然后在多个地方使用；当认为这个常量的值不合适的时候，修改它的定义，即可在所有使用到它的地方生效（而无需依次手工修改）；此外，还可以防止程序意外修改这个值。定义常量，只需要在基本类型前，加上<code>const</code>关键字即可；它是<code>constant</code>的缩写，意为常量。</p><p>当<code>const</code>与指针牵扯到一起，就有些复杂了。至少有以下几种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;                <span class="comment">// int 型变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cnst = <span class="number">1</span>;         <span class="comment">// int 型常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = &amp;val;             <span class="comment">// pi 本身是变量，通过 pi 访问的也是变量</span></span><br><span class="line">                            <span class="comment">// 正确：将变量地址赋值给变量的指针</span></span><br><span class="line">pi = &amp;cnst;                 <span class="comment">// 错误：不允许将常量的地址赋值给变量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = &amp;cnst;     <span class="comment">// pci 本身是变量，通过 pci 访问的是常量 (point to const)</span></span><br><span class="line">                            <span class="comment">// 正确：将常量地址赋值给常量的指针</span></span><br><span class="line">pci = &amp;val;                 <span class="comment">// 正确：允许将变量地址赋值给常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> cpi = &amp;val;      <span class="comment">// cpi 本身是常量，通过 cpi 访问的是变量</span></span><br><span class="line">                            <span class="comment">// 正确：允许将变量地址赋值给变量的指针</span></span><br><span class="line"><span class="keyword">int</span> fake = <span class="number">2</span>;               <span class="comment">// int 型变量</span></span><br><span class="line">cpi = &amp;fake;                <span class="comment">// 错误：cpi 本身是常量，不能在定义之外赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> cpci = &amp;val;</span><br><span class="line">                            <span class="comment">// cpci 本身是常量，通过 cpci 访问的也是常量</span></span><br><span class="line">                            <span class="comment">// 正确：允许将变量地址赋值给常量的指针</span></span><br><span class="line">cpci = &amp;fake;               <span class="comment">// 错误：cpci 本身是常量，不能在定义之外赋值</span></span><br><span class="line">cpci = &amp;cnst;               <span class="comment">// 错误：cpci 本身是常量，不能在定义之外赋值，哪怕是常量的地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在《程序员面试宝典》中关于<code>const</code>修饰指针的情况，作者将其分为以下四种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a = &amp;b;          <span class="comment">//情况1</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a = &amp;b;          <span class="comment">//情况2</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a = &amp;b;         <span class="comment">//情况3</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a = &amp;b;   <span class="comment">//情况4</span></span><br></pre></td></tr></table></figure><p>先看情况1，如果<code>const</code>位于星号的左侧，则<code>const</code>就是用来修饰指针所指向的变量，即指针指向为常量；如果<code>const</code>位于星号右侧，<code>const</code>就是修饰指针本身，即指针本身是常量。1和2的情况相同，都是指针所指向的内容为常量，这种情况下不允许对内容进行更改操作。</p><p>换句话说，如果 a 是一名仓库管理员的话，他所进入的仓库，里面的货物<code>*a</code>是他没有权限允许动的，仓库里面的东西原来是什么就是什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b =<span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a = &amp;b;</span><br><span class="line">*a = <span class="number">600</span>;           <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>但是也有别的办法修改<code>*a</code>的值，一个是通过改变 b 的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b =<span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a = &amp;b;</span><br><span class="line">b = <span class="number">600</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//得到600</span></span><br></pre></td></tr></table></figure><p>还有一种是让a指向别处(管理员换个仓库)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b =<span class="number">500</span>, c = <span class="number">600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a = &amp;b;</span><br><span class="line">a = &amp;c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//得到600</span></span><br></pre></td></tr></table></figure><p>此外，对于这种情况，可以先不初始化。因为虽然指针内容是常量，但指针本身不是常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br></pre></td></tr></table></figure><p>情况2与情况1相同，情况3位指针本身是敞亮，这种情况下不能对指针本身进行更改操作，而指针所指向的内容不是常量。举例来说，如果 a 是一名仓库管理员的话，他只能进入指定的仓库，而不能去别的仓库，所以<code>a++;</code>是错误的，但是这个仓库里面的货物是可以改动的，<code>*a = 600;</code>是正确的。</p><p>情况3定义时必须同时初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">500</span>, c = <span class="number">600</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;          <span class="comment">//错误 没有初始化</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a = &amp;b;     <span class="comment">//正确 必须初始化</span></span><br><span class="line">*a = <span class="number">600</span>;               <span class="comment">//正确 允许改值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a++ &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>对于情况4指针本身和指向的内容均为常亮，那么这个仓库管理员只能去特定的仓库，并且仓库里面所有的货物他都没有权限去改动。</p><h1 id="指针与数组"><a class="markdownIt-Anchor" href="#指针与数组"></a> 指针与数组</h1><h2 id="数组的名字被当做指针使用"><a class="markdownIt-Anchor" href="#数组的名字被当做指针使用"></a> 数组的名字被当做指针使用</h2><p>在 C 和 C++ 中，指针与数组有非常紧密的联系。实际上，使用数组的时候，编译器通常都是在操作指针。这里我们从两个角度说明数组名在很多时候被当做是一个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;(nums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (p == nums) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"true!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你执行这一小段代码，那么，不出意外的话，程序会在终端上打印<code>true!</code>，以及<code>nums</code>中的三个数字。这预示着，指针变量<code>p</code>保存的内容（也就是<code>nums[0]</code>的地址）和<code>nums</code>保存的内容是完全一样的；同时，编译器以相同的方式去解释<code>p</code>和<code>nums</code>。显然<code>p</code>是一个指向<code>int</code>型变量的指针，那么<code>nums</code>也就是一个指针了。</p><p>C++11 标准引入了<code>auto</code>关键字，它能够在定义变量时，探测初始值的类型，并为新定义的变量设置合适的类型。我们看看<code>auto</code>关键字作用于数组名字的时候，会发生什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> what = nums;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line">what = &amp;val;</span><br></pre></td></tr></table></figure><p>这份代码在 C++11 标准中，可以顺利通过。这说明<code>what</code>的类型，经由<code>auto</code>检测，是<code>int *</code>。</p><p>这两个例子，足以说明：当数组名字被当做是一个值来使用的时候，它就相当于是一个指针。</p><h2 id="也不是全部时候"><a class="markdownIt-Anchor" href="#也不是全部时候"></a> 也不是全部时候</h2><p>当然，也不是全部时候，数组名字都被当做是简单的指针。比如，前作中的使用方式表明，在数组名字被传入 <code>sizeof()</code>运算符的时候，它会被当做是一个真实的数组来看待。</p><h2 id="数组指针可以自增"><a class="markdownIt-Anchor" href="#数组指针可以自增"></a> 数组指针可以自增</h2><p>数组的指针，可以像 C++ 中<code>std::vector</code>的迭代器那样进行自增操作。这句话不是太严谨，因为，实际上是先有数组的指针，再有<code>std::vector</code>的迭代器；迭代器实际上是仿造数组的指针设计的功能。</p><p>前文提到，数组的指针，实际上是一个指向数组元素类型的对象的指针。数组的指针进行自增、自减运算，实际是将指针所指的位置，沿着数组向后或者向前移动一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> *iter, end = nums[len];                     <span class="comment">// end 是尾后指针</span></span><br><span class="line"><span class="keyword">for</span> (iter = nums; iter != end; ++iter) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的用法，就和<code>std::vector</code>的迭代器几乎没有差别了。</p><h2 id="数组指针可以进行加减运算"><a class="markdownIt-Anchor" href="#数组指针可以进行加减运算"></a> 数组指针可以进行加减运算</h2><p>数组的指针还可以进行加减运算。比如，在上述例子中<code>iter += 2</code>，就是将<code>iter</code>指针沿着数组向后移动 2 个元素。</p><p>两个指针如果指向同一个数组中的元素，那么它们可以做差。做差得到的结果是两个指针之间的距离，这个结果可以是负数（实际类型是<code>ptrdiff_t</code>）。例如，在上述例子中在循环体末尾处，如果进行<code>end - iter</code>计算，则其结果表示当前尚未打印的元素的数量。</p><h2 id="数组下标与指针加减"><a class="markdownIt-Anchor" href="#数组下标与指针加减"></a> 数组下标与指针加减</h2><p>上面提到，数组指针可以进行加减运算：数组指针与整数的加减，实际是将指针沿着数组进行移动，得到的结果还是一个指针。既然结果是指针，那么就可以解引用，访问数组中的元素。因此有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> *p = nums;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == *(p + i)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"true!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外的话，这一小段代码会连续打印五行<code>true!</code>。这提供了另一种访问数组内元素的方法；而事实上，在使用下标访问数组元素的时候，编译器都会转换成类似<code>*(nums + i)</code>的形式。也就是说，通过指针运算和解引用来访问数组元素，其实是更加本质的方式。</p><h1 id="函数与指针"><a class="markdownIt-Anchor" href="#函数与指针"></a> 函数与指针</h1><p>函数与指针，基本上是指针相关的话题中，最复杂的一个了。</p><h2 id="让函数返回一个数组的指针"><a class="markdownIt-Anchor" href="#让函数返回一个数组的指针"></a> 让函数返回一个数组的指针</h2><p>我们知道，函数在返回的过程中，会对返回值进行拷贝。因此，一个无法拷贝的对象，是无法被函数返回的。（也可以参考<a href="https://liam0205.me/2016/08/14/copy-control-in-Cpp/" target="_blank" rel="noopener">此篇</a>）数组是不能被拷贝的，所以函数无法直接返回数组。为了达到返回数组的目的，我们只能寄希望于让函数返回数组的指针（在 C++ 中还可以返回数组的引用）。</p><p>为此我们需要了解如何定义一个返回数组指针的函数。首先，我们来看一组数组的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];        <span class="comment">// arr 是一个数组，长度是 10，元素类型是 int 型</span></span><br><span class="line"><span class="keyword">int</span> *parr[<span class="number">10</span>];      <span class="comment">// parr 是一个指针数组，长度是 10，元素类型是 int *，也就是数组中存的是指针</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">                    <span class="comment">// p 是一个指针，它指向一个长度是 10 元素类型是 int 型的数组</span></span><br></pre></td></tr></table></figure><p>这样一来就不难构造返回数组的指针的函数定义了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *(func(param_list))[<span class="number">10</span>];</span><br><span class="line">                    <span class="comment">// 错误：func 是一个函数，param_list 是它的参数</span></span><br><span class="line">                    <span class="comment">// 它尝试返回一个长度为 10，元素类型为 int * 的数组</span></span><br><span class="line">                    <span class="comment">// 而数组是无法返回的</span></span><br><span class="line"><span class="keyword">int</span> (*func(param_list))[<span class="number">10</span>];</span><br><span class="line">                    <span class="comment">// 正确：func 是一个函数，param_list 是它的参数</span></span><br><span class="line">                    <span class="comment">// 它返回的是一个指针</span></span><br><span class="line">                    <span class="comment">// 这个指针指向了一个长度为 10 元素类型是 int 型的数组</span></span><br></pre></td></tr></table></figure><p>于是我们得到了此类函数定义的一般形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element_type (*func(param_list))[dimension]</span><br></pre></td></tr></table></figure><h2 id="函数的指针"><a class="markdownIt-Anchor" href="#函数的指针"></a> 函数的指针</h2><p>上文提到，无论是数据（变量）还是指令（函数），都是存放在虚存空间的。因此，既然有变量的指针，那么也一定会有函数的指针。这就是我们这一小节需要讨论的函数指针；这会逐渐引出本文最复杂的话题。</p><p>一个函数的类型，取决于它的输入和输出。这也就是说，一个函数的类型，应当包含它的返回值类型和参数列表。比如下面定义的函数，用于比较两个<code>int</code>型数据是否相等（这是一个仅用于示例而没有实际用处的函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>对于一个函数来说，如果你能拿到它的定义，就很容易能取得它的类型：只需要去掉函数名字就可以了。因此，定义一个指向该类型的函数指针，并不困难。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp;isEqual;     <span class="comment">// 定义了一个函数指针，指向 isEqual</span></span><br><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = isEqual;      <span class="comment">// 一个等价定义</span></span><br></pre></td></tr></table></figure><p>在这里，<code>pfunc</code>就是一个函数指针，它指向一个<code>bool (int, int)</code>类型的函数。也就是说，这类函数接收两个<code>int</code>型的参数，并返回一个<code>bool</code>类型的值。</p><p>值得一提的是，当函数名字作为值使用时，它会自动地转换成指针（有点像数组名字，不是吗）。因此，在函数指针的初始化或者复制的过程中，取值运算符是可选的。于是，上述两个定义语句是等价的。另一方面，函数指针作为函数调用使用时，它会自动转换成函数名（有点像数组指针，不是吗）。因此，这种情况下，解引用运算符是可选的。请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = isEqual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> res1 = isEqual(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 通过原函数名调用</span></span><br><span class="line"><span class="keyword">bool</span> res2 = (*pfunc)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 一个等价调用：通过函数指针，解引用调用</span></span><br><span class="line"><span class="keyword">bool</span> res3 = pfunc(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// 另一个等价调用：函数指针自动转换成函数名</span></span><br></pre></td></tr></table></figure><p>值得一提的是，不同类型的函数的指针之间，不存在任何的类型转换：你不能期待一个接受两个<code>int</code>型参数并返回<code>bool</code>值的函数的指针，经过类型转换，就能接受三个<code>int</code>型的参数。因此，对于重载的同名函数，他们的函数类型是不一样的，因此函数指针也不能是同一个。</p><h2 id="将函数指针作为参数传入另一个函数"><a class="markdownIt-Anchor" href="#将函数指针作为参数传入另一个函数"></a> 将函数指针作为参数传入另一个函数</h2><p>在传参的过程中（除了 C++ 的传引用），也是伴随着拷贝的过程。因此，一个对象如果不能拷贝，那么它就不能作为参数传入函数。无疑，函数是不能拷贝的，因此你无法将函数作为参数直接传给另一个函数。但是，指针是可以拷贝的，因此，你可以将函数指针作为参数，传给另一个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void addIfEqual(int lhs, int rhs, bool pfunc(int, int));</span><br><span class="line">                            <span class="comment">// addIfEqual 的第三个参数是一个函数定义</span></span><br><span class="line">                            <span class="comment">// 它会自动地转换成一个函数指针的参数</span></span><br><span class="line">void addIfEqual(int lhs, int rhs, bool (*pfunc)(int, int));</span><br><span class="line">                            <span class="comment">// 一个等价定义：显式地注明第三个参数是函数指针</span></span><br></pre></td></tr></table></figure><p>于是你可以这样使用这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfEqual(<span class="number">1</span>, <span class="number">1</span>, isEqual);</span><br></pre></td></tr></table></figure><p>此时，函数名<code>isEqual</code>作为引数被传入，它起到的是「值」的作用。因此，<code>isEqual</code>被自动地转换成指向该函数的指针。</p><h2 id="让函数返回一个函数的指针"><a class="markdownIt-Anchor" href="#让函数返回一个函数的指针"></a> 让函数返回一个函数的指针</h2><p>同样地，与数组类似，虽然我们无法返回一个函数，但是我们可以返回一个函数指针。我们回到 isEqual 的函数指针的定义上来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = isEqual;</span><br></pre></td></tr></table></figure><p>在这里，<code>pfunc</code>是一个指针，它指向了一个函数；该函数接收两个<code>int</code>型参数，并返回一个<code>bool</code>值。因此，仿造之前「返回数组指针的函数的定义形式」，我们不难得出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_return_type (*func(param_list))(outer_param_list)</span><br></pre></td></tr></table></figure><p>这里，<code>func(param_list)</code>是当前需要定义的函数；<code>outer_return_type</code>和<code>outer_param_list</code>分别是当前定义的函数返回的函数指针对应函数的返回值类型和参数列表。</p><h1 id="登峰造极的void0"><a class="markdownIt-Anchor" href="#登峰造极的void0"></a> 登峰造极的<code>(*(void(*)())0)();</code></h1><p>这恐怕是一个会令所有 C/C++ 程序员战栗不已的函数调用语句。因此，在解释这个语句之前，我愿意先给出它的含义，安抚读者战栗的心灵。它表示：<strong>访问内存地址<code>0</code>，将它作为一个参数列表和返回类型均为空的函数，并执行函数调用。</strong>（这是一个特殊场景下的函数调用，不用纠结为什么会调用 0 位置上的函数）</p><h2 id="类型定义与-c-风格的类型强制转换符"><a class="markdownIt-Anchor" href="#类型定义与-c-风格的类型强制转换符"></a> 类型定义与 C 风格的类型强制转换符</h2><p>C 风格的类型强制转换符应该不是个稀罕玩意儿。比如<code>(double)a</code>就能将变量<code>a</code>强制转换为<code>double</code>类型。在这个简单的例子里，我们希望能够找到一些朴素的规律，破解这一登峰造极而又令人战栗的函数调用语句。</p><p>同样以<code>double</code>类型及相关指针类型为例，我们首先看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a;       <span class="comment">// 定义了一个 double 型的变量</span></span><br><span class="line"><span class="keyword">double</span> *b;      <span class="comment">// 定义了一个 double * 型的变量（double 型的指针）</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">double</span>) c;     <span class="comment">// 将变量 c 强制转换为 double 类型</span></span><br><span class="line">(<span class="keyword">double</span> *) d;   <span class="comment">// 将变量 d 强制转换为 double * 类型</span></span><br></pre></td></tr></table></figure><p>我们不难发现，类型转换和对应类型的变量定义，有着千丝万缕的联系：首先去掉变量定义语句末尾的分号，然后去掉变量定义语句中的变量名，最后给剩余的部分加上括号——一个 C 风格的类型强制转换符，就得到了。</p><h2 id="破解谜题"><a class="markdownIt-Anchor" href="#破解谜题"></a> 破解谜题</h2><p>我们知道<code>void(*pfunc)();</code> 定义了一个函数指针<code>pfunc</code>，它指向的函数参数列表为空、返回值类型也为空。因此，<code>(void(*)())</code>就是一个 C 风格的类型转换符。</p><p>因此，<code>(void(*)())0</code>会将<code>0</code>转换成一个函数指针，然后交给<code>*</code>解引用，最后传入参数（空的参数列表 ()），执行函数调用。</p><blockquote><p>在 C++ 中，这个函数调用应该写作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>(*)()&gt;(<span class="number">0</span>))();</span><br></pre></td></tr></table></figure><p>显而易见，这个写法，相较 C 风格的类型强制转换符，要清晰明朗得多。因此，请不要再吐槽 C++ 风格的强制转换是「语法盐」了。</p></blockquote><p>转载自<a href="https://liam0205.me/2017/02/05/pointer-in-C-and-Cpp/" target="_blank" rel="noopener">《C和C++中的指针》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;指针是C语言的大杀器&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C++中的指针，是语言中相当犀利的工具。但它也是一把双刃剑，用得不好就是毁灭整个工程的大杀器。
    
    </summary>
    
      <category term="技术" scheme="https://blog.knightyui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://blog.knightyui.com/tags/C/"/>
    
      <category term="指针" scheme="https://blog.knightyui.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++中的虚函数和多态</title>
    <link href="https://blog.knightyui.com/2018/01/28/virtualFunctionAndPloymorphism/"/>
    <id>https://blog.knightyui.com/2018/01/28/virtualFunctionAndPloymorphism/</id>
    <published>2018-01-28T08:28:26.000Z</published>
    <updated>2018-07-29T12:39:07.921Z</updated>
    
    <content type="html"><![CDATA[<p><br>  面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。    通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而已统一的方式使用他们的对象。<a id="more"></a><br><br>OOP的核心思想是多态性(Ploymorphism)。多态这个词源于希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能够使用这些类型的“多种类型”而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是支持C++语言支持多态性的根本所在。<br><br>当我们使用基类的引用或者指针调用基类中定义的一个函数时，我们并不知道该函数真正的作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时彩会决定到底执行哪个版本的函数，判断的依据是引用或者指针所绑定的对象的真实类型。<br><br>另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或者非虚函数)调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。<br><br><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</strong></p><h1 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h1><p>虚函数通过<code>virtual</code>关键字来声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a person."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//子类中不用声明virtual</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a man."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CPerson *p = <span class="keyword">new</span> CMan();</span><br><span class="line">    p-&gt;hello();</span><br><span class="line">    <span class="comment">//I'm a man.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，通过基类指针调用虚函数时，子类的同名函数得到了执行。多态在C++中有三种形态：<br>1.通过基类指针调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。<br>2.通过基类引用调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。<br>3.基类或子类的成员函数中调用基类和子类的同名虚函数时，会调用对象的实际类型中的虚函数。</p><h1 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h1><p>我们可以在函数体的位置(即在声明语句的分号之前)书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。其中<code>=0</code>只能出现在类内部的虚函数声明语句处。包含纯虚函数的类不允许实例化，称为<strong>抽象类</strong>。事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CPerson p; <span class="comment">//compile error</span></span><br></pre></td></tr></table></figure><p>注意空方法、纯虚函数、方法声明的区别。类声明中的空方法给出了方法声明+方法定义。只声明但没有定义的方法将会产生链接错误，无论是否被调用过。</p><h1 id="访问级别"><a class="markdownIt-Anchor" href="#访问级别"></a> 访问级别</h1><p>虚函数的调用会在运行时动态匹配当前类型，然而成员函数的访问性检查是语法检查的一部分，在编译期完成。如果虚函数在父类中是<code>private</code>，即使在子类中是<code>public</code>，也不可以通过父类指针调用它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CPerson *p = <span class="keyword">new</span> CMan();</span><br><span class="line">p-&gt;hello(); <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure><h1 id="虚析构函数"><a class="markdownIt-Anchor" href="#虚析构函数"></a> 虚析构函数</h1><p>虚函数的机制使得我们可以通过更加通用的基类指针来操作对象。然而使用基类指针来<code>delete</code>对象则面临着问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPerson *p = <span class="keyword">new</span> CMan();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>上述代码只会回收<code>CMan</code>中<code>CPerson</code>部分所占用的内存，执行了<code>CPerson</code>的析构函数，却没有执行<code>CMan</code>的虚构函数。解决方法很直观，将析构函数设为<code>virtual</code>。</p><blockquote><p>构造函数不允许是虚函数，编译错。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~CPerson()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CMan()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CPerson *p = <span class="keyword">new</span> CMan();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>这样，<code>delete</code>时会先调用<code>~CMan()</code>再调用<code>~CPerson()</code>。</p><h1 id="构造函数调用虚函数"><a class="markdownIt-Anchor" href="#构造函数调用虚函数"></a> 构造函数调用虚函数</h1><p>当执行构造函数时，当前对象的类型为构造函数所属的类。所以在构造函数中调用虚函数和调用普通函数是一样的，不会动态联编，被调用的函数来自自己或者基类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a person."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bye, person."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CMan()&#123;</span><br><span class="line">            hello();</span><br><span class="line">            bye();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a man."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CReek</span>:</span><span class="keyword">public</span> CMan&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a reek."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bye, reek."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CReek r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的调用结果是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm a man.</span><br><span class="line">Bye, Person.</span><br></pre></td></tr></table></figure><p><code>hello</code>和<code>bye</code>都是虚函数，其中<code>hello</code>三个层级都有定义，但被执行的是当前类<code>CMan</code>中的定义；<code>bye</code>在上下两个层级中有定义，被执行的是上一级<code>CPerson</code>中的定义。可见，构造函数执行时当前对象的类型是定义构造函数的类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;  面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。    通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而已统一的方式使用他们的对象。
    
    </summary>
    
      <category term="技术" scheme="https://blog.knightyui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://blog.knightyui.com/tags/C/"/>
    
      <category term="虚函数" scheme="https://blog.knightyui.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="多态" scheme="https://blog.knightyui.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Josephus</title>
    <link href="https://blog.knightyui.com/2017/11/02/Josephus/"/>
    <id>https://blog.knightyui.com/2017/11/02/Josephus/</id>
    <published>2017-11-02T06:40:49.000Z</published>
    <updated>2018-07-29T12:39:07.920Z</updated>
    
    <content type="html"><![CDATA[<p>约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。<br>有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。<br>问题是，给定了n和k，一开始要站在什么地方才能避免被处决？</p><a id="more"></a><p>这个问题是以弗拉维奥·约瑟夫斯命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。<br>简化之后的问题就变成了，n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。</p><h1 id="一般解法"><a class="markdownIt-Anchor" href="#一般解法"></a> 一般解法</h1><p>非常容易想到的方法就是利用环链表来做，构建一个环链表，每个结点的编号为0, 1, … n-1。每次从当前位置向前移动m-1步，然后删除这个结点。最后剩下的结点就是胜利者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listInt;</span><br><span class="line"><span class="keyword">unsigned</span> i;</span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">listInt.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iterCurrent = listInt.begin();</span><br><span class="line"><span class="keyword">while</span> (listInt.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//前进m-1步</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (++iterCurrent == listInt.end())</span><br><span class="line">iterCurrent = listInt.begin();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//临时保存删除的节点</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iterDel = iterCurrent;</span><br><span class="line"><span class="keyword">if</span> (++iterCurrent == listInt.end())</span><br><span class="line">iterCurrent = listInt.begin();</span><br><span class="line">listInt.erase(iterDel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *iterCurrent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法效率很低，其时间复杂度为O(m*n)。当m和n很大时候，很难在短时间内得出结果，不过好处就是可以给出n-1个人出圈的顺序，只需要在删除之前保存一下。</p><h1 id="进阶解法"><a class="markdownIt-Anchor" href="#进阶解法"></a> 进阶解法</h1><p>普通的解法之所以复杂度高，是因为我们不知道哪个节点会保留下来。所以需要不断遍历删除，直到剩下最后一个节点。如果我们不通过遍历，而是直接计算出最后活下来的节点是哪个，就可以降低时间复杂度。<br>推导过程如下：<br>如果只剩下一个节点，那么幸存的节点就是该节点，编号为1，Live(1)=1;<br>如果剩下两个节点，幸存的节点为Live(2);<br>如果剩下三个节点，幸存的节点为Live(3) ;<br>…<br>如果剩下i个节点，幸存的节点为Live(i);<br>…<br>如果剩下n个节点，幸存的节点为Live(n);</p><p>我们已知Live(1)=1，如果确定Live(i-1)和Live(i)是什么关系，就可以递归过程求出Live(n)</p><p>如果一个节点数为n的链表，编号从头结点到尾节点为1~n，如果删除编号为s的一个节点，剩下的节点编号将会怎么变化？如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Josephus/Josephus1.jpg" alt="Josephus1" title="">                </div>                <div class="image-caption">Josephus1</div>            </figure><p>设原链表编号为y，删除一个节点之后的编号为x，那么我们可以得到以下的公式</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">y</span> = (x + s -<span class="number">1</span>) % n + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此可以根据Live(i-1)以及被删除的节点编号来求得Live(i)的值，那么现在问题变成了如何求被删除节点的编号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Josephus/Josephus2.jpg" alt="Josephus2" title="">                </div>                <div class="image-caption">Josephus2</div>            </figure><p>如图所示，对于每一个节点，如果报数值不到m，就会一直报数下去，1<sub>n</sub>2n~…由图我们可以得到报数值A与编号值B的关系，即</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">B</span> = (A - <span class="number">1</span>) % n + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果报到m，报数的节点就是要删除的节点，那么该节点的编号根据公式可以得出</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = (m - <span class="number">1</span>) % n + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得到s之后，我们可以通过上面第一步得出的关系</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Live<span class="comment">(i)</span> = <span class="comment">(Live(i - 1)</span> + s - <span class="number">1</span>) <span class="meta">%</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>把s带入之后，两式合并，结果为</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Live<span class="comment">(i)</span> = <span class="comment">(Live(i - 1)</span> + m - <span class="number">1</span>) <span class="meta">%</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>整个过程总结如下：<br>　　1、遍历链表，得到链表的节点数n，O(n)<br>　　2、根据n和m的值，以及上文推导的Live(i)与Live(i-1)的关系，递归求得幸存节点的编号。该递归是单决策递归且递归为n层，所以时间复杂度为O(n)<br>　　3、根据得到的幸存节点的编号，遍历链表找到该节点，O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。&lt;br&gt;
有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。&lt;br&gt;
问题是，给定了n和k，一开始要站在什么地方才能避免被处决？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.knightyui.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="约瑟夫环" scheme="https://blog.knightyui.com/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    
      <category term="算法" scheme="https://blog.knightyui.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++" scheme="https://blog.knightyui.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages+Hexo建立博客</title>
    <link href="https://blog.knightyui.com/2017/10/27/CreateWebsite/"/>
    <id>https://blog.knightyui.com/2017/10/27/CreateWebsite/</id>
    <published>2017-10-27T11:32:04.000Z</published>
    <updated>2018-07-29T12:39:07.920Z</updated>
    
    <content type="html"><![CDATA[<p>之前有用过WordPress直接建站，但是WordPress有两个不好的地方：<br>1、WordPress是动态的，对于服务器的要求比较高，配置比较低的服务器运行时候会加载很慢。<br>2、国内想用自己的域名建网站必须要备案，比较麻烦。</p><p>恰好听到同学说可以用Hexo和Github Pages来做静态的个人博客。相比WordPress，Hexo+Github Pages可以不用购买服务器，省了一笔钱。其次Hexo是静态的，加载速度很快，很适合个人博客的搭建。</p><a id="more"></a><h1 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h1><p>要想使用Hexo，首先要在你的电脑上面安装Node.js和Git工具<br>安装完毕之后，在你想放置网站文件的地方建立一个文件夹。比如 D:/Hexo。进入到文件夹之后使用git工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g <span class="comment"># 或者hexo generate</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s <span class="comment"># 或者hexo server，可以在http://localhost:4000/ 查看</span></span></span><br></pre></td></tr></table></figure><p>这里提一下Hexo常用的几个命令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span>(hexo g)       生成静态文件，会在当前目录下生成一个新的public文件夹</span><br><span class="line">hexo server(hexo s)         启动本地Web服务，用于博客的预览</span><br><span class="line">hexo deploy(hexo d)         部署博客到远端，比如GitHub</span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span>         新建文章，路径在/source/<span class="number">_</span>posts</span><br><span class="line">hexo <span class="keyword">new</span> pages <span class="string">"pageName"</span>   新建页面，路径在/source</span><br></pre></td></tr></table></figure><p>安装完成之后，就要选择你需要使用的主题了。Hexo有很多主题可以选择，我这里使用的是Next主题。在GitHub上面搜索到项目之后会有很详细的使用说明，这里不再赘述。<br><br>关于主题的个性化定制，一般主题会有很多地方可以个性化更改，可以根据官方文档自行更改，或者使用搜索引擎来获取个性化定制的细节，每个主题都不相同。<br><br>需要注意的是，更新主题的时候如果是修改了css文件，需要先清除之前生成的缓存文件，不然有可能无法正常生效。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure><h1 id="github-pages设置"><a class="markdownIt-Anchor" href="#github-pages设置"></a> GitHub Pages设置</h1><h2 id="什么是github-pages"><a class="markdownIt-Anchor" href="#什么是github-pages"></a> 什么是GitHub Pages</h2><p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>本来是用来介绍托管在Github上面的项目，不过由于空间免费稳定，被很多人拿来搭建个人博客。<br><br>每个人只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。可以通过 <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> 来直接访问你的个人主页。<br><br>这里需要特别注意一下，个人网页的网站内容是在master分支下面的。</p><h2 id="配置和使用github-pages"><a class="markdownIt-Anchor" href="#配置和使用github-pages"></a> 配置和使用GitHub Pages</h2><p>我们如何让本地的项目与远程的Github建立联系呢？一般来说有两种方法。一种是通过GitHub的账号密码来进行操作，第二种是比较推荐，通过SSH keys来建立连接。</p><h3 id="检查ssh-keys的设置"><a class="markdownIt-Anchor" href="#检查ssh-keys的设置"></a> 检查SSH keys的设置</h3><p>首先需要检查电脑上现有的SSH key：<br><code>cd ~/.ssh 检查本机的ssh密钥</code><br>如果提示：No such file or directory 说明你第一次使用git，按照下面的步骤创建新的SSH key</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure><p>然后系统会提示你输入密码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="xml"><span class="tag">&lt;<span class="name">输入加密串</span>&gt;</span></span></span><br><span class="line"><span class="xml">Enter same passphrase again:<span class="tag">&lt;<span class="name">再次输入</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="添加ssh-key到github"><a class="markdownIt-Anchor" href="#添加ssh-key到github"></a> 添加SSH key到Github</h3><p>1 在本机设置SSH key之后，需要添加到Github上，已完成SSH链接的设置。<br><br>首先打开本地id_rsa.pub文件，(参考地址： C:\Users\yourname.ssh\id_rsa.pub)。文件内容为刚才生成的密钥，复制文件内容。<br>2 登陆Github，点击右上角Settings-&gt;SSH and GPG keys 。新建SSH keys，内容为刚才复制的密钥内容。<br>3 测试下面的命令，看是否成功，命令不要更改<br><code>$ ssh -T git@GitHub.com</code><br>如果看到如下反馈</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'GitHub.com (207.97.227.239)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>不要紧张，输入 yes 就好，然后会看到成功的信息。<br>有的时候会提示permission denied，此时一般是ssh公钥没有添加到本地SSH环境中，只需要使用ssh-add命令添加公钥即可。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span><span class="bash"> your_publickey</span></span><br></pre></td></tr></table></figure><h2 id="设置用户信息"><a class="markdownIt-Anchor" href="#设置用户信息"></a> 设置用户信息</h2><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="selector-class">.name</span> <span class="string">"username"</span><span class="comment">//用户名</span></span><br><span class="line">$ git config --global user<span class="selector-class">.email</span>  <span class="string">"username@gmail.com"</span><span class="comment">//填写自己的邮箱</span></span><br></pre></td></tr></table></figure><h1 id="域名"><a class="markdownIt-Anchor" href="#域名"></a> 域名</h1><p>上面已经完成了基本环境的设置，但是搭建个人博客，最重要的是要有一个自己的域名。这里域名推荐去Godaddy上面购买，选好自己喜欢的域名之后，建立解析即可。注意，域名解析要建立两个A的解析记录，分别为192.30.252.154和192.30.252.153。然后建立一个CNAME类型的解析，主机记录设置为www，记录值设置为你的Github Pages的网址，<a href="http://xn--yourname-jo1ot97l.github.io" target="_blank" rel="noopener">比如yourname.github.io</a>。<br><br>做完上面的步骤，其实还是不能直接通过自己的域名去访问Github Pages的。还需要两个小步骤的设置：<br>先进入Github，进入Github Pages的仓库，然后找到Settings-&gt;Options-&gt;GitHub Pages 找到Custom domain，把你设置的个人域名添加进去。<br><br>然后在仓库的根目录添加一个CNAME文件，文件内容为你的域名<br><br>完成上面的设置，已经可以成功通过自己的域名访问</p><h1 id="把博客部署到github"><a class="markdownIt-Anchor" href="#把博客部署到github"></a> 把博客部署到Github</h1><p>前面我们已经完成了所有的基础设置，并且已经可以在本地访问自己的博客，下面我们需要完成的就是把本地的博客部署到Github上面。Hexo提供了deploy插件让我们使用，方便部署到很多平台。如果部署到Github，需要先安装扩展<br><code>$ npm install hexo-deployer-git --save</code><br>然后在配置文件_config.xml中做下面的修改：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: git</span><br><span class="line">    <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:yourname/yourname.github.io.git <span class="comment">//可以在项目仓库clone看到地址</span></span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><p>然后再执行<br><code>hexo d</code><br>就能完成部署，这时通过你的域名就能直接访问博客了。</p><h1 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h1><p><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">手把手教你使用Hexo + Github Pages搭建个人独立博客</a><br><a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="noopener">MarkDown语法说明(简体中文版)</a><br><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a><br><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">Hexo Markdown 简明语法手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有用过WordPress直接建站，但是WordPress有两个不好的地方：&lt;br&gt;
1、WordPress是动态的，对于服务器的要求比较高，配置比较低的服务器运行时候会加载很慢。&lt;br&gt;
2、国内想用自己的域名建网站必须要备案，比较麻烦。&lt;/p&gt;
&lt;p&gt;恰好听到同学说可以用Hexo和Github Pages来做静态的个人博客。相比WordPress，Hexo+Github Pages可以不用购买服务器，省了一笔钱。其次Hexo是静态的，加载速度很快，很适合个人博客的搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.knightyui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.knightyui.com/tags/Hexo/"/>
    
      <category term="Github Pages" scheme="https://blog.knightyui.com/tags/Github-Pages/"/>
    
  </entry>
  
</feed>
