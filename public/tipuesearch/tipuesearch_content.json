{"pages":[{"title":"Docker简介及使用","url":"/2018/03/27/docker-tutorial/","text":"Docker，这个名词第一次听到是从浩哥那里。大概是去年秋天的时候，浩哥让我在服务器上使用docker撘一个内网穿透frp服务器，用来做树莓派的公网访问。后来由于不再使用树莓派也没有再继续了解下去。最近在V站也经常看到关于Docker的帖子，看起来还是蛮有用的，先挖个坑，毕业之前补完。","tags":"docker linux"},{"title":"Hexo博客GitHub备份，还有一些常用Git操作","url":"/2018/03/25/BackUpHexoAndGit/","text":"年后换了电脑，博客的文件也从旧电脑转到了新的电脑上面，但是总觉得这种方式很不方便，把文件拷来拷去。由于博客是发布在GitHubPages上的，就想能不能把博客的生成文件也传到GitHub上。但是这样又出现一个新的问题，一个博客我要用两个仓库来存。突然想起来Git的branch，这岂不是正好用来存储源文件和生成的静态文件？首先在仓库新建一个Branch，我这里就直接命名为Hexo了，作为Hexo源文件的备份分支。然后把这个分支设置为默认分支，这样写完博客之后直接把源文件git push到GitHub的仓库中，再也不怕硬盘坏掉或者换电脑了。需要这些源文件的时候git clone下来，然后依次执行123npm install -g hexo-clinpm install hexonpm install这样环境就跟之前一模一样了。最近也在学习使用Git了，这个工具真的很强大，后悔没有早点开始使用，在自己的服务器上也搭建了一个Git仓库，记录一些常用的命令：一般来说日常使用只需要记住下图六个命令。下面是常用的Git命令清单： 新建代码仓库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [curl] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时用户信息git config [--global] user.name \"name\"git config [--global] user.email \"eamil_adress\" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 参考链接：常用Git命令清单","tags":"hexo github git"},{"title":"C++中的指针","url":"/2018/01/30/pointInCPP/","text":"","tags":"c++ 指针"},{"title":"C++中的虚函数和多态","url":"/2018/01/28/virtualFunctionAndPloymorphism/","text":"面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。 通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而已统一的方式使用他们的对象。OOP的核心思想是多态性(Ploymorphism)。多态这个词源于希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能够使用这些类型的“多种类型”而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是支持C++语言支持多态性的根本所在。当我们使用基类的引用或者指针调用基类中定义的一个函数时，我们并不知道该函数真正的作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时彩会决定到底执行哪个版本的函数，判断的依据是引用或者指针所绑定的对象的真实类型。另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或者非虚函数)调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。 虚函数虚函数通过virtual关键字来声明。lang: C++1234567891011121314151617181920class CPerson&#123; public: virtual vlid hello()&#123; cout&lt;&lt;\"I'm a person.\"&lt;&lt;endl; &#125;&#125;;class CMan:public CPerson&#123; public: //子类中不用声明virtual void hello()&#123; cout&lt;&lt;\"I'm a man.\"&lt;&lt;endl; &#125;&#125;;int main()&#123; CPerson *p = new CMan(); p-&gt;hello(); //I'm a man. return 0;&#125;上述代码中，通过基类指针调用虚函数时，子类的同名函数得到了执行。多态在C++中有三种形态：1.通过基类指针调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。2.通过基类引用调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。3.基类或子类的成员函数中调用基类和子类的同名虚函数时，会调用对象的实际类型中的虚函数。 纯虚函数我们可以在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处。包含纯虚函数的类不允许实例化，称为抽象类。事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。lang: C++123456class CPerson&#123; public: virtual void hello() = 0;&#125;;CPerson p; //compile error注意空方法、纯虚函数、方法声明的区别。类声明中的空方法给出了方法声明+方法定义。只声明但没有定义的方法将会产生链接错误，无论是否被调用过。 访问级别虚函数的调用会在运行时动态匹配当前类型，然而成员函数的访问性检查是语法检查的一部分，在编译期完成。如果虚函数在父类中是private，即使在子类中是public，也不可以通过父类指针调用它：lang: C++12345678910class CPerson&#123; virtual void hello();&#125;;class CMan:public CPerson&#123; public: virtual void hello();&#125;;CPerson *p = new CMan();p-&gt;hello(); //编译出错 虚析构函数虚函数的机制使得我们可以通过更加通用的基类指针来操作对象。然而使用基类指针来delete对象则面临着问题。 lang: C++12CPerson *p = new CMan();delete p; 上述代码只会回收CMan中CPerson部分所占用的内存，执行了CPerson的析构函数，却没有执行CMan的虚构函数。解决方法很直观，将析构函数设为virtual。 构造函数不允许是虚函数，编译错。 lang: C++1234567891011class CPerson&#123; public: virtual ~CPerson()&#123;&#125;;&#125;;class CMan:public CPerson&#123; public: ~CMan()&#123;&#125;;&#125;;CPerson *p = new CMan();delete p; 这样，delete时会先调用~CMan()再调用~CPerson()。 构造函数调用虚函数当执行构造函数时，当前对象的类型为构造函数所属的类。所以在构造函数中调用虚函数和调用普通函数是一样的，不会动态联编，被调用的函数来自自己活着基类。lang: C++123456789101112131415161718192021222324252627282930313233class CPerson&#123; public: virtual void hello()&#123; cout&lt;&lt;\"I'm a person.\"&lt;&lt;endl; &#125; virtual void bye()&#123; cout&lt;&lt;\"Bye, person.\"&lt;&lt;endl; &#125;&#125;;class CMan:public CPerson&#123; public: CMan()&#123; hello(); bye(); &#125; void hello()&#123; cout&lt;&lt;\"I'm a man.\"&lt;&lt;endl; &#125;&#125;;class CReek:public CMan&#123; public: void hello()&#123; cout&lt;&lt;\"I'm a reek.\"&lt;&lt;endl; &#125; void bye()&#123; cout&lt;&lt;\"Bye, reek.\"&lt;&lt;endl; &#125;&#125;;int main()&#123; CReek r; return 0;&#125;上述的调用结果是：lang: C++12I'm a man.Bye, Person. hello和bye都是虚函数，其中hello三个层级都有定义，但被执行的是当前类CMan中的定义；bye在上下两个层级中有定义，被执行的是上一级CPerson中的定义。可见，构造函数执行时当前对象的类型是定义构造函数的类。","tags":"c++ 虚函数 多态"},{"title":"Josephus","url":"/2017/11/02/Josephus/","text":"约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了n和k，一开始要站在什么地方才能避免被处决？这个问题是以弗拉维奥·约瑟夫斯命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。简化之后的问题就变成了，n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 一般解法非常容易想到的方法就是利用环链表来做，构建一个环链表，每个结点的编号为0, 1, …… n-1。每次从当前位置向前移动m-1步，然后删除这个结点。最后剩下的结点就是胜利者。1234567891011121314151617181920212223242526int Josephus(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; list&lt;int&gt; listInt; unsigned i; //初始化链表 for (i = 0; i &lt; n; i++) &#123; listInt.push_back(i); &#125; list&lt;int&gt;::iterator iterCurrent = listInt.begin(); while (listInt.size() &gt; 1) &#123; //前进m-1步 for (i = 0; i &lt; m - 1; i++) &#123; if (++iterCurrent == listInt.end()) iterCurrent = listInt.begin(); &#125; //临时保存删除的节点 list&lt;int&gt;::iterator iterDel = iterCurrent; if (++iterCurrent == listInt.end()) iterCurrent = listInt.begin(); listInt.erase(iterDel); &#125; return *iterCurrent;&#125; 上述方法效率很低，其时间复杂度为O(m*n)。当m和n很大时候，很难在短时间内得出结果，不过好处就是可以给出n-1个人出圈的顺序，只需要在删除之前保存一下。 进阶解法普通的解法之所以复杂度高，是因为我们不知道哪个节点会保留下来。所以需要不断遍历删除，直到剩下最后一个节点。如果我们不通过遍历，而是直接计算出最后活下来的节点是哪个，就可以降低时间复杂度。推导过程如下：如果只剩下一个节点，那么幸存的节点就是该节点，编号为1，Live(1)=1;如果剩下两个节点，幸存的节点为Live(2);如果剩下三个节点，幸存的节点为Live(3) ;…如果剩下i个节点，幸存的节点为Live(i);…如果剩下n个节点，幸存的节点为Live(n); 我们已知Live(1)=1，如果确定Live(i-1)和Live(i)是什么关系，就可以递归过程求出Live(n) 如果一个节点数为n的链表，编号从头结点到尾节点为1~n，如果删除编号为s的一个节点，剩下的节点编号将会怎么变化？如下图所示设原链表编号为y，删除一个节点之后的编号为x，那么我们可以得到以下的公式1y = (x + s -1) % n + 1 因此可以根据Live(i-1)以及被删除的节点编号来求得Live(i)的值，那么现在问题变成了如何求被删除节点的编号如图所示，对于每一个节点，如果报数值不到m，就会一直报数下去，1~n~2n~…由图我们可以得到报数值A与编号值B的关系，即1B = (A - 1) % n + 1 如果报到m，报数的节点就是要删除的节点，那么该节点的编号根据公式可以得出1s = (m - 1) % n + 1 得到s之后，我们可以通过上面第一步得出的关系1Live(i) = (Live(i - 1) + s - 1) % i + 1 把s带入之后，两式合并，结果为1Live(i) = (Live(i - 1) + m - 1) % i + 1 整个过程总结如下： 1、遍历链表，得到链表的节点数n，O(n) 2、根据n和m的值，以及上文推导的Live(i)与Live(i-1)的关系，递归求得幸存节点的编号。该递归是单决策递归且递归为n层，所以时间复杂度为O(n) 3、根据得到的幸存节点的编号，遍历链表找到该节点，O(n)123456789101112class Solution &#123;public: int LastRemaining_Solution(unsigned int n, unsigned int m) &#123; if(n==0) return -1; if(n==1) return 0; else return (LastRemaining_Solution(n-1,m)+m)%n; &#125;&#125;;","tags":"约瑟夫环 算法 c++"},{"title":"GitHub Pages+Hexo建立博客","url":"/2017/10/27/CreateWebsite/","text":"之前有用过WordPress直接建站，但是WordPress有两个不好的地方：1、WordPress是动态的，对于服务器的要求比较高，配置比较低的服务器运行时候会加载很慢。2、国内想用自己的域名建网站必须要备案，比较麻烦。 恰好听到同学说可以用Hexo和Github Pages来做静态的个人博客。相比WordPress，Hexo+Github Pages可以不用购买服务器，省了一笔钱。其次Hexo是静态的，加载速度很快，很适合个人博客的搭建。 安装环境要想使用Hexo，首先要在你的电脑上面安装Node.js和Git工具安装完毕之后，在你想放置网站文件的地方建立一个文件夹。比如 D:/Hexo。进入到文件夹之后使用git工具123456$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 这里提一下Hexo常用的几个命令：12345hexo generate(hexo g) 生成静态文件，会在当前目录下生成一个新的public文件夹hexo server(hexo s) 启动本地Web服务，用于博客的预览hexo deploy(hexo d) 部署博客到远端，比如GitHubhexo new \"postName\" 新建文章，路径在/source/_postshexo new pages \"pageName\" 新建页面，路径在/source 安装完成之后，就要选择你需要使用的主题了。Hexo有很多主题可以选择，我这里使用的是Next主题。在GitHub上面搜索到项目之后会有很详细的使用说明，这里不再赘述。关于主题的个性化定制，一般主题会有很多地方可以个性化更改，可以根据官方文档自行更改，或者使用搜索引擎来获取个性化定制的细节，每个主题都不相同。需要注意的是，更新主题的时候如果是修改了css文件，需要先清除之前生成的缓存文件，不然有可能无法正常生效。12$ hexo clean$ hexo generate GitHub Pages设置什么是GitHub PagesGitHub Pages本来是用来介绍托管在Github上面的项目，不过由于空间免费稳定，被很多人拿来搭建个人博客。每个人只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。可以通过 http://username.github.io 来直接访问你的个人主页。这里需要特别注意一下，个人网页的网站内容是在master分支下面的。 配置和使用GitHub Pages我们如何让本地的项目与远程的Github建立联系呢？一般来说有两种方法。一种是通过GitHub的账号密码来进行操作，第二种是比较推荐，通过SSH keys来建立连接。 检查SSH keys的设置首先需要检查电脑上现有的SSH key：cd ~/.ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你第一次使用git，按照下面的步骤创建新的SSH key123$ ssh-keygen -t rsa -C \"邮件地址\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 然后系统会提示你输入密码：12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入&gt; 添加SSH key到Github1 在本机设置SSH key之后，需要添加到Github上，已完成SSH链接的设置。首先打开本地id_rsa.pub文件，(参考地址： C:\\Users\\yourname.ssh\\id_rsa.pub)。文件内容为刚才生成的密钥，复制文件内容。2 登陆Github，点击右上角Settings-&gt;SSH and GPG keys 。新建SSH keys，内容为刚才复制的密钥内容。3 测试下面的命令，看是否成功，命令不要更改$ ssh -T git@GitHub.com如果看到如下反馈123The authenticity of host 'GitHub.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入 yes 就好，然后会看到成功的信息。有的时候会提示permission denied，此时一般是ssh公钥没有添加到本地SSH环境中，只需要使用ssh-add命令添加公钥即可。1ssh-add your_publickey 设置用户信息现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。12$ git config --global user.name \"username\"//用户名$ git config --global user.email \"username@gmail.com\"//填写自己的邮箱 域名上面已经完成了基本环境的设置，但是搭建个人博客，最重要的是要有一个自己的域名。这里域名推荐去Godaddy上面购买，选好自己喜欢的域名之后，建立解析即可。注意，域名解析要建立两个A的解析记录，分别为192.30.252.154和192.30.252.153。然后建立一个CNAME类型的解析，主机记录设置为www，记录值设置为你的Github Pages的网址，比如yourname.github.io。做完上面的步骤，其实还是不能直接通过自己的域名去访问Github Pages的。还需要两个小步骤的设置：先进入Github，进入Github Pages的仓库，然后找到Settings-&gt;Options-&gt;GitHub Pages 找到Custom domain，把你设置的个人域名添加进去。然后在仓库的根目录添加一个CNAME文件，文件内容为你的域名完成上面的设置，已经可以成功通过自己的域名访问 把博客部署到Github前面我们已经完成了所有的基础设置，并且已经可以在本地访问自己的博客，下面我们需要完成的就是把本地的博客部署到Github上面。Hexo提供了deploy插件让我们使用，方便部署到很多平台。如果部署到Github，需要先安装扩展$ npm install hexo-deployer-git --save然后在配置文件_config.xml中做下面的修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git //可以在项目仓库clone看到地址 branch: master 然后再执行hexo d就能完成部署，这时通过你的域名就能直接访问博客了。 参考链接手把手教你使用Hexo + Github Pages搭建个人独立博客MarkDown语法说明(简体中文版)hexo的next主题个性化配置教程","tags":"hexo github-pages"},{"title":"","url":"/404.html","text":"","tags":""},{"title":"","url":"/about.html","text":"","tags":""},{"title":"archives","url":"/archives/index.html","text":"","tags":""},{"title":"sitemap","url":"/sitemap/index.html","text":"","tags":""},{"title":"分类","url":"/categories/index.html","text":"","tags":""},{"title":"关于我","url":"/about/index.html","text":"本科就读东南大学CS屁民一个，在努力。","tags":""},{"title":"标签","url":"/tags/index.html","text":"","tags":""}]}