<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KnightYui&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-27T18:06:59.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KnightYui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker简介及使用</title>
    <link href="http://yoursite.com/2018/03/27/docker-tutorial/"/>
    <id>http://yoursite.com/2018/03/27/docker-tutorial/</id>
    <published>2018-03-27T10:28:20.000Z</published>
    <updated>2018-03-27T18:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker，这个名词第一次听到是从浩哥那里。大概是去年秋天的时候，浩哥让我在服务器上使用docker撘一个内网穿透frp服务器，用来做树莓派的公网访问。后来由于不再使用树莓派也没有再继续了解下去。最近在V站也经常看到关于Docker的帖子，看起来还是蛮有用的，先挖个坑，毕业之前补完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker，这个名词第一次听到是从浩哥那里。大概是去年秋天的时候，浩哥让我在服务器上使用docker撘一个内网穿透frp服务器，用来做树莓派的公网访问。后来由于不再使用树莓派也没有再继续了解下去。最近在V站也经常看到关于Docker的帖子，看起来还是蛮有用的，先挖个坑，毕
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客GitHub备份，还有一些常用Git操作</title>
    <link href="http://yoursite.com/2018/03/25/BackUpHexoAndGit/"/>
    <id>http://yoursite.com/2018/03/25/BackUpHexoAndGit/</id>
    <published>2018-03-24T17:30:32.000Z</published>
    <updated>2018-03-28T13:15:22.647Z</updated>
    
    <content type="html"><![CDATA[<p>年后换了电脑，博客的文件也从旧电脑转到了新的电脑上面，但是总觉得这种方式很不方便，把文件拷来拷去。<br><br>由于博客是发布在GitHubPages上的，就想能不能把博客的生成文件也传到GitHub上。但是这样又出现一个新的问题，一个博客我要用两个仓库来存。突然想起来Git的branch，这岂不是正好用来存储源文件和生成的静态文件？<a id="more"></a><br>首先在仓库新建一个Branch，我这里就直接命名为Hexo了，作为Hexo源文件的备份分支。然后把这个分支设置为默认分支，这样写完博客之后直接把源文件git push到GitHub的仓库中，再也不怕硬盘坏掉或者换电脑了。需要这些源文件的时候git clone下来，然后依次执行<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> -g hexo-cli</div><div class="line">npm <span class="keyword">install</span> hexo</div><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure><br>这样环境就跟之前一模一样了。<br><img src="/images/BackUpHexoAndGit/hexo-backup.png" alt="branch"><br>最近也在学习使用Git了，这个工具真的很强大，后悔没有早点开始使用，在自己的服务器上也搭建了一个Git仓库，记录一些常用的命令：<br>一般来说日常使用只需要记住下图六个命令。<br><img src="/images/BackUpHexoAndGit/GitCommand.png" alt="GitCommand"><br>下面是常用的Git命令清单：</p><h1 id="新建代码仓库"><a href="#新建代码仓库" class="headerlink" title="新建代码仓库"></a>新建代码仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></div><div class="line"><span class="meta">$</span><span class="bash"> git init</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></div><div class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [curl]</span></div></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示当前的Git配置</span></div><div class="line">$ git<span class="built_in"> config </span>--list</div><div class="line"></div><div class="line"><span class="comment"># 编辑Git配置文件</span></div><div class="line">$ git<span class="built_in"> config </span>-e [--global]</div><div class="line"></div><div class="line"><span class="comment"># 设置提交代码时用户信息</span></div><div class="line">git<span class="built_in"> config </span>[--global] user.name <span class="string">"name"</span></div><div class="line">git<span class="built_in"> config </span>[--global] user.email <span class="string">"eamil_adress"</span></div></pre></td></tr></table></figure></p><h1 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></div><div class="line">git add [file1] [file2] ...</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></div><div class="line">git add [dir]</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git add .</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></div><div class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></div><div class="line"><span class="meta">$</span><span class="bash"> git add -p</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></div></pre></td></tr></table></figure><h1 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></div><div class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></div><div class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></div><div class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></div><div class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></div></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></div></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></div><div class="line"><span class="meta">$</span><span class="bash"> git tag</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></div><div class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></div><div class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></div><div class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></div><div class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></div></pre></td></tr></table></figure><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></div><div class="line"><span class="meta">$</span><span class="bash"> git status</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></div><div class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></div><div class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></div><div class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></div><div class="line"><span class="meta">$</span><span class="bash"> git diff</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></div><div class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></div><div class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></div><div class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></div><div class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></div><div class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></div><div class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></div><div class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></div><div class="line"><span class="meta">$</span><span class="bash"> git reflog</span></div></pre></td></tr></table></figure><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></div><div class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></div><div class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></div><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></div></pre></td></tr></table></figure><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></div><div class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></div><div class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></div><div class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></div><div class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></div><div class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></div><div class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></div><div class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></div><div class="line"><span class="meta">$</span><span class="bash"> git stash</span></div><div class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></div></pre></td></tr></table></figure><p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用Git命令清单</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年后换了电脑，博客的文件也从旧电脑转到了新的电脑上面，但是总觉得这种方式很不方便，把文件拷来拷去。&lt;br&gt;&lt;br&gt;由于博客是发布在GitHubPages上的，就想能不能把博客的生成文件也传到GitHub上。但是这样又出现一个新的问题，一个博客我要用两个仓库来存。突然想起来Git的branch，这岂不是正好用来存储源文件和生成的静态文件？
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C++中的指针</title>
    <link href="http://yoursite.com/2018/01/30/pointInCPP/"/>
    <id>http://yoursite.com/2018/01/30/pointInCPP/</id>
    <published>2018-01-30T11:08:33.000Z</published>
    <updated>2018-03-28T11:10:32.564Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="指针" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++中的虚函数和多态</title>
    <link href="http://yoursite.com/2018/01/28/virtualFunctionAndPloymorphism/"/>
    <id>http://yoursite.com/2018/01/28/virtualFunctionAndPloymorphism/</id>
    <published>2018-01-28T08:28:26.000Z</published>
    <updated>2018-03-28T13:19:43.043Z</updated>
    
    <content type="html"><![CDATA[<p><br>  面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。    通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而已统一的方式使用他们的对象。<a id="more"></a><br><br>OOP的核心思想是多态性(Ploymorphism)。多态这个词源于希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能够使用这些类型的“多种类型”而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是支持C++语言支持多态性的根本所在。<br><br>当我们使用基类的引用或者指针调用基类中定义的一个函数时，我们并不知道该函数真正的作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时彩会决定到底执行哪个版本的函数，判断的依据是引用或者指针所绑定的对象的真实类型。<br><br>另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或者非虚函数)调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。<br><br><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</strong></p><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>虚函数通过<code>virtual</code>关键字来声明。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> vlid <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a person."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">//子类中不用声明virtual</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a man."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    CPerson *p = <span class="keyword">new</span> CMan();</div><div class="line">    p-&gt;hello();</div><div class="line">    <span class="comment">//I'm a man.</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>上述代码中，通过基类指针调用虚函数时，子类的同名函数得到了执行。多态在C++中有三种形态：<br>1.通过基类指针调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。<br>2.通过基类引用调用基类和子类的同名函数时，会调用对象的实际类型中的虚函数。<br>3.基类或子类的成员函数中调用基类和子类的同名虚函数时，会调用对象的实际类型中的虚函数。</p><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>我们可以在函数体的位置(即在声明语句的分号之前)书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。其中<code>=0</code>只能出现在类内部的虚函数声明语句处。包含纯虚函数的类不允许实例化，称为<strong>抽象类</strong>。事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CPerson p; <span class="comment">//compile error</span></div></pre></td></tr></table></figure><br>注意空方法、纯虚函数、方法声明的区别。类声明中的空方法给出了方法声明+方法定义。只声明但没有定义的方法将会产生链接错误，无论是否被调用过。</p><h1 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h1><p>虚函数的调用会在运行时动态匹配当前类型，然而成员函数的访问性检查是语法检查的一部分，在编译期完成。如果虚函数在父类中是<code>private</code>，即使在子类中是<code>public</code>，也不可以通过父类指针调用它：<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CPerson *p = <span class="keyword">new</span> CMan();</div><div class="line">p-&gt;hello(); <span class="comment">//编译出错</span></div></pre></td></tr></table></figure></p><h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><p>虚函数的机制使得我们可以通过更加通用的基类指针来操作对象。然而使用基类指针来<code>delete</code>对象则面临着问题。</p><figure class="highlight abnf"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CPerson *p = new CMan()<span class="comment">;</span></div><div class="line">delete p<span class="comment">;</span></div></pre></td></tr></table></figure><p>上述代码只会回收<code>CMan</code>中<code>CPerson</code>部分所占用的内存，执行了<code>CPerson</code>的析构函数，却没有执行<code>CMan</code>的虚构函数。解决方法很直观，将析构函数设为<code>virtual</code>。</p><blockquote><p>构造函数不允许是虚函数，编译错。</p></blockquote><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">virtual</span> ~CPerson()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        ~CMan()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CPerson *p = <span class="keyword">new</span> CMan();</div><div class="line"><span class="keyword">delete</span> p;</div></pre></td></tr></table></figure><p>这样，<code>delete</code>时会先调用<code>~CMan()</code>再调用<code>~CPerson()</code>。</p><h1 id="构造函数调用虚函数"><a href="#构造函数调用虚函数" class="headerlink" title="构造函数调用虚函数"></a>构造函数调用虚函数</h1><p>当执行构造函数时，当前对象的类型为构造函数所属的类。所以在构造函数中调用虚函数和调用普通函数是一样的，不会动态联编，被调用的函数来自自己活着基类。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a person."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bye, person."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMan</span>:</span><span class="keyword">public</span> CPerson&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        CMan()&#123;</div><div class="line">            hello();</div><div class="line">            bye();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a man."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CReek</span>:</span><span class="keyword">public</span> CMan&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm a reek."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bye, reek."</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    CReek r;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>上述的调用结果是：<br><figure class="highlight erlang"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I'm a man.</div><div class="line">Bye, Person.</div></pre></td></tr></table></figure></p><p><code>hello</code>和<code>bye</code>都是虚函数，其中<code>hello</code>三个层级都有定义，但被执行的是当前类<code>CMan</code>中的定义；<code>bye</code>在上下两个层级中有定义，被执行的是上一级<code>CPerson</code>中的定义。可见，构造函数执行时当前对象的类型是定义构造函数的类。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;  面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。    通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而已统一的方式使用他们的对象。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="虚函数" scheme="http://yoursite.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Josephus</title>
    <link href="http://yoursite.com/2017/11/02/Josephus/"/>
    <id>http://yoursite.com/2017/11/02/Josephus/</id>
    <published>2017-11-02T06:40:49.000Z</published>
    <updated>2018-03-27T18:01:58.134Z</updated>
    
    <content type="html"><![CDATA[<p>约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。<br>有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。<br>问题是，给定了n和k，一开始要站在什么地方才能避免被处决？<br><a id="more"></a><br>这个问题是以弗拉维奥·约瑟夫斯命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。<br>简化之后的问题就变成了，n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 </p><h1 id="一般解法"><a href="#一般解法" class="headerlink" title="一般解法"></a>一般解法</h1><p>非常容易想到的方法就是利用环链表来做，构建一个环链表，每个结点的编号为0, 1, …… n-1。每次从当前位置向前移动m-1步，然后删除这个结点。最后剩下的结点就是胜利者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listInt;</div><div class="line"><span class="keyword">unsigned</span> i;</div><div class="line"><span class="comment">//初始化链表</span></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">listInt.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iterCurrent = listInt.begin();</div><div class="line"><span class="keyword">while</span> (listInt.size() &gt; <span class="number">1</span>) &#123;</div><div class="line"><span class="comment">//前进m-1步</span></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</div><div class="line"><span class="keyword">if</span> (++iterCurrent == listInt.end())</div><div class="line">iterCurrent = listInt.begin();</div><div class="line">&#125;</div><div class="line"><span class="comment">//临时保存删除的节点</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iterDel = iterCurrent;</div><div class="line"><span class="keyword">if</span> (++iterCurrent == listInt.end())</div><div class="line">iterCurrent = listInt.begin();</div><div class="line">listInt.erase(iterDel);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> *iterCurrent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述方法效率很低，其时间复杂度为O(m*n)。当m和n很大时候，很难在短时间内得出结果，不过好处就是可以给出n-1个人出圈的顺序，只需要在删除之前保存一下。</p><h1 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h1><p>普通的解法之所以复杂度高，是因为我们不知道哪个节点会保留下来。所以需要不断遍历删除，直到剩下最后一个节点。如果我们不通过遍历，而是直接计算出最后活下来的节点是哪个，就可以降低时间复杂度。<br>推导过程如下：<br>如果只剩下一个节点，那么幸存的节点就是该节点，编号为1，Live(1)=1;<br>如果剩下两个节点，幸存的节点为Live(2);<br>如果剩下三个节点，幸存的节点为Live(3) ;<br>…<br>如果剩下i个节点，幸存的节点为Live(i);<br>…<br>如果剩下n个节点，幸存的节点为Live(n);</p><p>我们已知Live(1)=1，如果确定Live(i-1)和Live(i)是什么关系，就可以递归过程求出Live(n)</p><p>如果一个节点数为n的链表，编号从头结点到尾节点为1~n，如果删除编号为s的一个节点，剩下的节点编号将会怎么变化？如下图所示<br><img src="/images/Josephus/Josephus1.jpg" alt="Josephus1"><br>设原链表编号为y，删除一个节点之后的编号为x，那么我们可以得到以下的公式<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">y</span> = (x + s -<span class="number">1</span>) % n + <span class="number">1</span></div></pre></td></tr></table></figure></p><p>因此可以根据Live(i-1)以及被删除的节点编号来求得Live(i)的值，那么现在问题变成了如何求被删除节点的编号<br><img src="/images/Josephus/Josephus2.jpg" alt="Josephus2"><br>如图所示，对于每一个节点，如果报数值不到m，就会一直报数下去，1~n~2n~…由图我们可以得到报数值A与编号值B的关系，即<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">B</span> = (A - <span class="number">1</span>) % n + <span class="number">1</span></div></pre></td></tr></table></figure></p><p>如果报到m，报数的节点就是要删除的节点，那么该节点的编号根据公式可以得出<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">s</span> = (m - <span class="number">1</span>) % n + <span class="number">1</span></div></pre></td></tr></table></figure></p><p>得到s之后，我们可以通过上面第一步得出的关系<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Live<span class="comment">(i)</span> = <span class="comment">(Live(i - 1)</span> + s - <span class="number">1</span>) <span class="meta">%</span> i + <span class="number">1</span></div></pre></td></tr></table></figure></p><p>把s带入之后，两式合并，结果为<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Live<span class="comment">(i)</span> = <span class="comment">(Live(i - 1)</span> + m - <span class="number">1</span>) <span class="meta">%</span> i + <span class="number">1</span></div></pre></td></tr></table></figure></p><p>整个过程总结如下：<br>　　1、遍历链表，得到链表的节点数n，O(n)<br>　　2、根据n和m的值，以及上文推导的Live(i)与Live(i-1)的关系，递归求得幸存节点的编号。该递归是单决策递归且递归为n层，所以时间复杂度为O(n)<br>　　3、根据得到的幸存节点的编号，遍历链表找到该节点，O(n)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。&lt;br&gt;有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。&lt;br&gt;问题是，给定了n和k，一开始要站在什么地方才能避免被处决？&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="约瑟夫环" scheme="http://yoursite.com/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages+Hexo建立博客</title>
    <link href="http://yoursite.com/2017/10/27/CreateWebsite/"/>
    <id>http://yoursite.com/2017/10/27/CreateWebsite/</id>
    <published>2017-10-27T11:32:04.000Z</published>
    <updated>2018-03-28T13:13:30.518Z</updated>
    
    <content type="html"><![CDATA[<p>之前有用过WordPress直接建站，但是WordPress有两个不好的地方：<br>1、WordPress是动态的，对于服务器的要求比较高，配置比较低的服务器运行时候会加载很慢。<br>2、国内想用自己的域名建网站必须要备案，比较麻烦。</p><p>恰好听到同学说可以用Hexo和Github Pages来做静态的个人博客。相比WordPress，Hexo+Github Pages可以不用购买服务器，省了一笔钱。其次Hexo是静态的，加载速度很快，很适合个人博客的搭建。<br><a id="more"></a></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>要想使用Hexo，首先要在你的电脑上面安装Node.js和Git工具<br>安装完毕之后，在你想放置网站文件的地方建立一个文件夹。比如 D:/Hexo。进入到文件夹之后使用git工具<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></div><div class="line"><span class="meta">$</span><span class="bash"> hexo init blog</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></div><div class="line"><span class="meta">$</span><span class="bash"> npm install</span></div><div class="line"><span class="meta">$</span><span class="bash"> hexo g <span class="comment"># 或者hexo generate</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> hexo s <span class="comment"># 或者hexo server，可以在http://localhost:4000/ 查看</span></span></div></pre></td></tr></table></figure></p><p>这里提一下Hexo常用的几个命令：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">generate</span>(hexo g)       生成静态文件，会在当前目录下生成一个新的public文件夹</div><div class="line">hexo server(hexo s)         启动本地Web服务，用于博客的预览</div><div class="line">hexo deploy(hexo d)         部署博客到远端，比如GitHub</div><div class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span>         新建文章，路径在/source/<span class="number">_</span>posts</div><div class="line">hexo <span class="keyword">new</span> pages <span class="string">"pageName"</span>   新建页面，路径在/source</div></pre></td></tr></table></figure></p><p>安装完成之后，就要选择你需要使用的主题了。Hexo有很多主题可以选择，我这里使用的是Next主题。在GitHub上面搜索到项目之后会有很详细的使用说明，这里不再赘述。<br><br>关于主题的个性化定制，一般主题会有很多地方可以个性化更改，可以根据官方文档自行更改，或者使用搜索引擎来获取个性化定制的细节，每个主题都不相同。<br><br>需要注意的是，更新主题的时候如果是修改了css文件，需要先清除之前生成的缓存文件，不然有可能无法正常生效。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo <span class="keyword">generate</span></div></pre></td></tr></table></figure></p><h1 id="GitHub-Pages设置"><a href="#GitHub-Pages设置" class="headerlink" title="GitHub Pages设置"></a>GitHub Pages设置</h1><h2 id="什么是GitHub-Pages"><a href="#什么是GitHub-Pages" class="headerlink" title="什么是GitHub Pages"></a>什么是GitHub Pages</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>本来是用来介绍托管在Github上面的项目，不过由于空间免费稳定，被很多人拿来搭建个人博客。<br><br>每个人只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。可以通过 <a href="http://username.github.io" target="_blank" rel="external">http://username.github.io</a> 来直接访问你的个人主页。<br><br>这里需要特别注意一下，个人网页的网站内容是在master分支下面的。</p><h2 id="配置和使用GitHub-Pages"><a href="#配置和使用GitHub-Pages" class="headerlink" title="配置和使用GitHub Pages"></a>配置和使用GitHub Pages</h2><p>我们如何让本地的项目与远程的Github建立联系呢？一般来说有两种方法。一种是通过GitHub的账号密码来进行操作，第二种是比较推荐，通过SSH keys来建立连接。</p><h3 id="检查SSH-keys的设置"><a href="#检查SSH-keys的设置" class="headerlink" title="检查SSH keys的设置"></a>检查SSH keys的设置</h3><p>首先需要检查电脑上现有的SSH key：<br><code>cd ~/.ssh   检查本机的ssh密钥</code><br>如果提示：No such file or directory 说明你第一次使用git，按照下面的步骤创建新的SSH key<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址"</span></div><div class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</div><div class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</div></pre></td></tr></table></figure></p><p>然后系统会提示你输入密码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="xml"><span class="tag">&lt;<span class="name">输入加密串</span>&gt;</span></span></div><div class="line"><span class="xml">Enter same passphrase again:<span class="tag">&lt;<span class="name">再次输入</span>&gt;</span></span></div></pre></td></tr></table></figure></p><h3 id="添加SSH-key到Github"><a href="#添加SSH-key到Github" class="headerlink" title="添加SSH key到Github"></a>添加SSH key到Github</h3><p>1 在本机设置SSH key之后，需要添加到Github上，已完成SSH链接的设置。<br><br>首先打开本地id_rsa.pub文件，(参考地址： C:\Users\yourname.ssh\id_rsa.pub)。文件内容为刚才生成的密钥，复制文件内容。<br>2 登陆Github，点击右上角Settings-&gt;SSH and GPG keys 。新建SSH keys，内容为刚才复制的密钥内容。<br>3 测试下面的命令，看是否成功，命令不要更改<br><code>$ ssh -T git@GitHub.com</code><br>如果看到如下反馈<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'GitHub.com (207.97.227.239)' can't be established.</span></div><div class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></div><div class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</div></pre></td></tr></table></figure></p><p>不要紧张，输入 yes 就好，然后会看到成功的信息。<br>有的时候会提示permission denied，此时一般是ssh公钥没有添加到本地SSH环境中，只需要使用ssh-add命令添加公钥即可。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-<span class="keyword">add</span><span class="bash"> your_publickey</span></div></pre></td></tr></table></figure></p><h2 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h2><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user<span class="selector-class">.name</span> <span class="string">"username"</span><span class="comment">//用户名</span></div><div class="line">$ git config --global user<span class="selector-class">.email</span>  <span class="string">"username@gmail.com"</span><span class="comment">//填写自己的邮箱</span></div></pre></td></tr></table></figure></p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>上面已经完成了基本环境的设置，但是搭建个人博客，最重要的是要有一个自己的域名。这里域名推荐去Godaddy上面购买，选好自己喜欢的域名之后，建立解析即可。注意，域名解析要建立两个A的解析记录，分别为192.30.252.154和192.30.252.153。然后建立一个CNAME类型的解析，主机记录设置为www，记录值设置为你的Github Pages的网址，比如yourname.github.io。<br><br>做完上面的步骤，其实还是不能直接通过自己的域名去访问Github Pages的。还需要两个小步骤的设置：<br>先进入Github，进入Github Pages的仓库，然后找到Settings-&gt;Options-&gt;GitHub Pages 找到Custom domain，把你设置的个人域名添加进去。<br><br>然后在仓库的根目录添加一个CNAME文件，文件内容为你的域名<br><br>完成上面的设置，已经可以成功通过自己的域名访问</p><h1 id="把博客部署到Github"><a href="#把博客部署到Github" class="headerlink" title="把博客部署到Github"></a>把博客部署到Github</h1><p>前面我们已经完成了所有的基础设置，并且已经可以在本地访问自己的博客，下面我们需要完成的就是把本地的博客部署到Github上面。Hexo提供了deploy插件让我们使用，方便部署到很多平台。如果部署到Github，需要先安装扩展<br><code>$ npm install hexo-deployer-git --save</code><br>然后在配置文件_config.xml中做下面的修改：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">deploy</span>:</div><div class="line">    <span class="attribute">type</span>: git</div><div class="line">    <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:yourname/yourname.github.io.git <span class="comment">//可以在项目仓库clone看到地址</span></div><div class="line">    <span class="attribute">branch</span>: master</div></pre></td></tr></table></figure></p><p>然后再执行<br><code>hexo d</code><br>就能完成部署，这时通过你的域名就能直接访问博客了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">手把手教你使用Hexo + Github Pages搭建个人独立博客</a><br><a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="external">MarkDown语法说明(简体中文版)</a><br><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="external">hexo的next主题个性化配置教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有用过WordPress直接建站，但是WordPress有两个不好的地方：&lt;br&gt;1、WordPress是动态的，对于服务器的要求比较高，配置比较低的服务器运行时候会加载很慢。&lt;br&gt;2、国内想用自己的域名建网站必须要备案，比较麻烦。&lt;/p&gt;
&lt;p&gt;恰好听到同学说可以用Hexo和Github Pages来做静态的个人博客。相比WordPress，Hexo+Github Pages可以不用购买服务器，省了一笔钱。其次Hexo是静态的，加载速度很快，很适合个人博客的搭建。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Github Pages" scheme="http://yoursite.com/tags/Github-Pages/"/>
    
  </entry>
  
</feed>
